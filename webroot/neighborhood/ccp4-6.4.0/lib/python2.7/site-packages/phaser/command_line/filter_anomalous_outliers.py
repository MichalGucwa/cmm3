
from __future__ import division
import iotbx.phil
from libtbx.utils import Sorry
import sys

def filter_anomalous_outliers (f_obs, wavelength, scattering_type,
    verbose=True, out=sys.stdout) :
  from phaser.phenix_adaptors import sad_target
  import phaser
  from cctbx import miller
  from scitbx.array_family import flex
  from scitbx import matrix
  assert f_obs.is_xray_amplitude_array() and f_obs.anomalous_flag()
  r_free_flags = f_obs.customized_copy(
    data=flex.bool(f_obs.indices().size(), False))
  data = sad_target.data_adaptor(
    f_obs=f_obs,
    r_free_flags=r_free_flags)
  inp = phaser.InputEP_AUTO()
  inp.setSPAC_NAME(str(f_obs.space_group_info()))
  inp.setCELL6(f_obs.unit_cell().parameters())
  inp.setCRYS_MILLER(data.indices)
  inp.addCRYS_ANOM_DATA(
    "xtal",
    "wave",
    data.f_obs_p,
    data.sigmas_p,
    data.present_p,
    data.f_obs_m,
    data.sigmas_m,
    data.present_m,
    )
  inp.setCOMP_AVER()
  inp.setWAVE( wavelength )
  inp.setATOM_CHAN_BFAC_WILS( True )
  inp.setHKLO( False )
  inp.setXYZO( False )
  inp.setVERB(verbose)
  inp.setHAND( "OFF" )
  inp.addLLGC_SCAT( scattering_type )
  inp.addATOM_FULL(
    "xtal",
    scattering_type,
    True,
    ( 0, 0, 0 ),
    0,
    True,
    0,
    False,
    matrix.rec( [ 1, 1, 1, 0, 0, 0 ], [ 3, 2 ] ),
    True,
    True,
    True,
    True,
    "S1"
    )
  inp.setMACA_PROT( "OFF" )
  #inp.setOUTL_REJE( False )
  inp.setLLGC_COMP( False )
  inp.setMACA_PROT( "DEFAULT" )
  inp.setMACS_PROT( "CUSTOM" )
  inp.addMACS(
    ref_k = False,
    ref_b = False,
    ref_sigma = False,
    ref_xyz = False,
    ref_occ = False,
    ref_bfac = False,
    ref_fdp = False,
    ref_sa = False,
    ref_sb = False,
    ref_sp = True,
    ref_sd = True,
    ref_pk = False,
    ref_pb = False,
    ncyc = 50,
    target = "NOT_ANOM_ONLY",
    minimizer = "BFGS",
    )
  phaser_out = phaser.Output()
  phaser_out.setPackagePhenix(out)
  result = phaser.runEP_SAD( inp, phaser_out )
  sele = result.getSelected()
  bad_indices = data.indices.select(~(result.getSelected()))
  print >> out, "%d Friedel pairs rejected" % bad_indices.size()
  bad_indices.extend(-bad_indices)
  bad_set = miller.set(
    crystal_symmetry=f_obs.crystal_symmetry(),
    indices=bad_indices,
    anomalous_flag=True)
  keep_obs = f_obs.lone_set(other=bad_set)
  print >> out, "Input array:", f_obs.indices().size()
  print >> out, "Filtered data:", keep_obs.indices().size()
  return keep_obs

master_phil = iotbx.phil.parse("""
data = None
  .type = path
labels = None
  .type = str
wavelength = None
  .type = float
scattering_type = None
  .type = str
output_file_name = None
  .type = path
""", process_includes=True)

def run (args, out=sys.stdout) :
  from iotbx.file_reader import any_file
  import iotbx.phil
  cmdline = iotbx.phil.process_command_line_with_files(
    args=args,
    master_phil=master_phil,
    reflection_file_def="data",
    float_def="wavelength")
  params = cmdline.work.extract()
  if (params.data is None) :
    raise Sorry("Reflections file required.")
  f = any_file(params.data)
  f.check_file_type("hkl")
  obs = None
  for miller_array in f.file_server.miller_arrays :
    if (miller_array.info().label_string() == params.labels) :
      obs = miller_array
      break
    elif (params.labels is None) and (miller_array.anomalous_flag()) :
      if (miller_array.is_xray_amplitude_array()) :
        obs = miller_array
        break
      elif (miller_array.is_xray_intensity_array()) and (obs is None) :
        obs = miller_array
  if (obs is None) :
    raise Sorry("Anomalous data not found in input.")
  if (obs.is_xray_intensity_array()) :
    obs = obs.french_wilson()
  keep_obs = filter_anomalous_outliers(
    f_obs=obs,
    wavelength=params.wavelength,
    scattering_type=params.scattering_type,
    verbose=True,
    out=out)
  if (params.output_file_name is not None) :
    mtz_out = keep_obs.as_mtz_dataset(column_root_label="F")
    mtz_out.mtz_object().write(params.output_file_name)
    print >> out, "Wrote %s" % params.output_file_name
  return keep_obs

if (__name__ == "__main__") :
  run(sys.argv[1:])
