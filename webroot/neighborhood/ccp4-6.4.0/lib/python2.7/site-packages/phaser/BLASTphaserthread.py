import os, time, posixpath
import threading
from threading import Thread
import logging
import traceback
import subprocess
import scitbx
import re
import BLASTMRutils
from phaser import CalcCCFromMRsolutions




class ThreadLogger():
    def __init__(self, logger, mylock=None):
        self.logger = logger
        self.mylock = mylock


    def log(self,loglevel, mstr):
 # protect stdout from multiple output if we're multiprocessing
        if self.mylock != None:
            self.mylock.acquire()
        self.logger.log(loglevel, mstr)
        self.logger.handlers[0].flush()
        self.logger.handlers[1].flush()
        if self.mylock != None:
            self.mylock.release()




class PhaserRunner(Thread):
    def __init__ (self,phaserexe, baseinputfname, modelinputfname, calclabel,
      logger, rootstr, topfolder = "", searches=None, totalsearches = None,
      mylock = None, targetpdbid = "", threadnumber = 0, maxthreads = 1, minmodelorder = 0):
        Thread.__init__(self)
        self.phaserexe = phaserexe
        self.searches = searches
        self.totalsearches = totalsearches
        self.baseinputfname = baseinputfname
        self.calclabel = calclabel
        self.topfolder = topfolder
        self.mylock = mylock
        self.tlogger = ThreadLogger(logger, mylock)
        self.modelinputfname = modelinputfname
        self.osdepbool = False
        self.rootstr = rootstr
        self.errorcodesum = 0
        self.minmodelorder = minmodelorder
        self.targetpdbid = targetpdbid
        self.prefix = "the "
        self.maxthreads = maxthreads
# label thread with our tag so we can identify it as ours in GetActivethreads()
        self.name = self.prefix + str(threadnumber) + ". thread"

        if os.sys.platform == "win32":
            self.osdepbool = True



    def PhaserRun(self,path):
# concatenate the two or three input scripts into MRinput.txt that is used by phaser
        baseinputfile = open(self.baseinputfname,"r")
        baseinput = baseinputfile.read()
        baseinputfile.close()

        modelinputfile = open(os.path.join(path,self.modelinputfname),"r")
        mstr = modelinputfile.read()
        modelinputfile.close()
# ignore VRMS in solution for first fixed component and template solutions so get rid of any SOLU ENSE lines
        modelinput_no_vrms = re.sub("SOLU ENSE.*\n", "", mstr)

        self.tlogger.log(logging.DEBUG, "Concatenating: " + self.calclabel + "MRinput.txt = " \
         + self.baseinputfname + " + rootstr + " + self.modelinputfname)
# Avoid race condition so not just the very first thread continues with self.name being assigned
# but waits a little until all other threads have also had their self.name assigned
        time.sleep(1)
# number of our threads is the count of self.name assigned to "phaser-"
        nactivethreads = len(self.GetActivethreads())
# crank up the throttle by using more CPUs if they are idle
        nopenmpthreads = max(1,self.maxthreads/(nactivethreads+1))
        jobstr = "JOBS %d\n" %nopenmpthreads

        myinput = baseinput + self.rootstr + jobstr + modelinput_no_vrms
        inputfilename = posixpath.join(path,self.calclabel + "MRinput.txt")
        inputfile = open(inputfilename, "w")
        inputfile.write(myinput)
        inputfile.close()

        command = self.phaserexe
        output = subprocess
        retval = 0
        try:
            self.tlogger.log(logging.INFO, self.name + " is executing Phaser in folder, "\
             + path + "\n\n" + myinput)

            myproc = subprocess.Popen(command, shell=self.osdepbool,
              stdin = subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            (stdoutdata, stderrdata) = myproc.communicate( input = myinput )
            retval = myproc.returncode
        except Exception, m:
            self.failure = True
            self.tlogger.log(logging.ERROR, m)

        finally:
            if (retval != 0):
                self.tlogger.log(logging.ERROR, "Something went wrong with the "\
                   "phaser calculation. Return code is: " + str(retval) + "\n" \
                   + stderrdata)

                self.errorcodesum += retval

            return stdoutdata




    def AbortRequested(self):
# stop further phaser jobs if this file is present
        stop1 = os.path.exists(posixpath.join(self.topfolder,"StopThreadsGracefully"))
# or present in the directory above
        stop2 = os.path.exists(posixpath.join(self.topfolder,"..","StopThreadsGracefully"))
        if stop1 or stop2:
            return True
        else:
            return False



    def GetActivethreads(self):
# list names of still active threads
        active = [t.name for t in threading.enumerate()]
        setofthreadnames = set(active)
        if self.name in setofthreadnames:
            active.remove(self.name)

        namesofproperthreads = []
# avoid listing names of spurious threads not created explicitly by us
        for t in active:
            if t.find(self.prefix) > -1:
# filter them out by if they are not tagged with our prefix
                namesofproperthreads.append(t)

        return namesofproperthreads



    def run(self):
        try:
            completedrunfname = posixpath.join(self.topfolder, self.calclabel
             + self.targetpdbid + "_DoneMRJobs.txt")
            testsol = BLASTMRutils.BLASTMRutils(self.topfolder, completedrunfname,
             self.mylock)
            for i, models in enumerate( self.searches ):
                if self.AbortRequested():
                    break
# create modelsdir as concatenated PDB codes separated by commas
                modelsdir = [ [e[0] for e in  e1]  for e1 in models[:-1]][0]
                workdir = ",".join( modelsdir )

                MRfolder = posixpath.join(self.topfolder, "MR", workdir)
                MRfolder = posixpath.relpath(MRfolder, self.topfolder)

                self.tlogger.log(logging.INFO,"%d. MR calculation out of %s by %s"
                 %((i+1), len(self.searches), self.name))

                for partmodels in models[1]:
                    modelorder = len(partmodels.split(","))
                    if self.minmodelorder > modelorder:
                        continue
                    self.tlogger.log(logging.INFO,
                     "%s: modelorder %s" %(self.name, modelorder))

                    if self.AbortRequested():
                        break
                    bsolved = [False]
                    founddir = [""]
                    if testsol.PhaserRanPartModelsBefore(founddir,partmodels,bsolved) == True:
                        if bsolved[0] == True: # and solved it
                            self.tlogger.log(logging.INFO,
                             "%s: A previous job found the partial structure %s in %s"
                             %(self.name,partmodels, founddir[0]))
                            self.tlogger.log(logging.INFO,"%s: Adding one more partial model"\
                             %self.name)
                            continue
                        """
                        else:
                            self.tlogger.log(logging.INFO,
                             "%s: A previous job didn't find the partial structure %s in %s"
                             %(self.name,partmodels, workdir))
                            self.tlogger.log(logging.INFO,"%s: Moving on to next search order"\
                             %self.name)

                            break
                        """

# Run phaser with the model created by PrepareInputfiles
                    rootname = posixpath.relpath(MRfolder) + posixpath.sep \
                     + self.calclabel + "{" + workdir + "}" + partmodels
                    self.rootstr = "ROOT " + rootname + "\n"
                    self.modelinputfname = "modelinput{" + partmodels + "}.txt"
                    stdoutput = self.PhaserRun(MRfolder)
                    phaserlogfile = open(rootname + ".log","w")
                    phaserlogfile.write(stdoutput)
                    phaserlogfile.close()

# see if phaser found a solution for these models
# "models" is the search order for this MR calculation: pdb_a, pdb_b, pdb_c,...pdb_m, pdb_n
                    solfname = self.calclabel + "{" + workdir + "}" + partmodels + ".sol"
                    nPartSolWithThisStrategy = testsol.IsthereaPartialSolution(
                      self.calclabel, workdir, partmodels, solfname)

                    testsol.NoticeCompletedPhaserRun(workdir, partmodels,
                     nPartSolWithThisStrategy)

                    if nPartSolWithThisStrategy < 0:
                        self.tlogger.log(logging.INFO,
                         "%s: Phaser didn't even write a solution file, %s, for the %s job"\
                         %(self.name, partmodels, modelsdir))
                        break
                    if nPartSolWithThisStrategy == 0:
                        self.tlogger.log(logging.INFO,
                         "%s: Phaser didn't find a partial solution, %s, for the %s job"\
                         %(self.name, partmodels, modelsdir))
                    if nPartSolWithThisStrategy > 0:
                        self.tlogger.log(logging.INFO,
                         "%s: Phaser found a partial solution, %s, for the %s job"\
                         %(self.name, partmodels, modelsdir))

                    MRfolder = posixpath.join(self.topfolder, "MR", workdir)
                    CCoutput = CalcCCFromMRsolutions.CalcCCFromMRsolution(self.targetpdbid,
                        MRfolder, self.calclabel, workdir, partmodels, bCalcCC = True)
                    self.tlogger.log(logging.INFO, CCoutput)

# list names of still active threads
            namesofproperthread = self.GetActivethreads()
            threadnames = ", ".join(namesofproperthread)
            if threadnames == "":
                threadnames = "no others"
            self.tlogger.log(logging.INFO,"%s is done and waits for %s to finish.\n"
             %(self.name,threadnames))

        except Exception, m:
            self.tlogger.log(logging.ERROR, self.name + ": " + str(m) + "\n" \
              + traceback.format_exc())
            self.errorcodesum += 1
            raise Exception, m

