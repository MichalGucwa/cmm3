
import os, re, glob, sys
import phaser.test_phaser_parsers
from phaser import template
from phaser import matching
from cctbx import sgtbx
from cctbx import uctbx
import scitbx.math
import iotbx.pdb
from phaser import CalcCCFromMRsolutions


def IsSolFileValid(solfname):
    b = True
    try:
        phaser.test_phaser_parsers.SolutionFileParser(open(solfname))
    except Exception, m:
        b = False

    finally:
        return b



# workaround until ListEdit.cc is fixed
def AreMatching(mtzfname, templsolfnames, mrsolfname, modelfname, mrresolution=2.5):
    mtz = iotbx.mtz.object(mtzfname)
    myparm = mtz.crystals()[0].unit_cell_parameters()
    ucell = uctbx.unit_cell(parameters = myparm)
    space_group_hall = mtz.space_group_info().group()
    crystal = matching.CrystalInfo( space_group = space_group_hall, cell=ucell)
    mroot = iotbx.pdb.input(modelfname).construct_hierarchy()
    ensemble = matching.EnsembleInfo.from_hierarchy( root = mroot )

    matches = []
    foundit = False
# allow reading an array of template solution files
    if not IsSolFileValid(templsolfnames[0]):
        return (foundit, matches)

    templparser = phaser.test_phaser_parsers.SolutionFileParser(open(templsolfnames[0]))
    templsols = templparser.get_dot_sol()
# having read the first template solution file now extend the mrsolution object with
# solutions from additional soution files
    for i, templsolfname in enumerate(templsolfnames):
        if i == 0:
            continue

        if not IsSolFileValid(templsolfname):
            continue

        templparser = phaser.test_phaser_parsers.SolutionFileParser(open(templsolfname))
        othersols = templparser.get_dot_sol()
        for sol in othersols:
            templsols.append(sol)
# all template solutions from all template solution files are now stored in templsols
#
    reference = []
    for tmpls in templsols:
        for peak in tmpls.KNOWN:
            reference.append(
                matching.Labelled.phaser_mr_solution(
                    rotation = peak.getR(),
                    translation = peak.getFracT(),
                    crystal = crystal,
                    ensemble = ensemble,
                    dmin = mrresolution
                    )
                )

    ref_origins = [ matching.OriginSearchEntity( r ) for r in reference ]
#
# read the mr solution file
    if not IsSolFileValid(mrsolfname):
        return (foundit, matches)

    mrparser = phaser.test_phaser_parsers.SolutionFileParser(open(mrsolfname))
    mrsols = mrparser.get_dot_sol()

    for ref_origin in ref_origins:
        match = []
        for sol in mrsols:
            trial = [
                matching.Labelled.phaser_mr_solution(
                    rotation = peak.getR(),
                    translation = peak.getFracT(),
                    crystal = crystal,
                    ensemble = ensemble,
                    dmin = 2.5
                    )
                for peak in sol.KNOWN
                ]
# try matching each template solution with each mr solution
            m = matching.phaser_style_equivalence_match(
              left = [ref_origin],
              right = [ matching.OriginSearchEntity( t ) for t in trial ]
              )
            if m:
                foundit = True
            match.append( m)
        matches.append(match)
#
    return (foundit, matches)



class BLASTMRutils():
    def __init__(self, topfolder, completedrunfname="", mylock = None):
        self.topfolder = topfolder
        self.completedrunfname = completedrunfname
        self.mylock = mylock
# array that'll hold MR solution, template solution, FTF_scrores data, VRMS and LLG float values
        self.mrsol = [None,None,None,None,None,None,None,None,None,[],[]]



    def IsthereaPartialSolution(self,calclabel,modeldir, partmodels,
     solutionfname = ""):
# match the templatesolution folder which is named as an alphanumerically sorted pdbs
# Returns 1 if template = solution otherwise 0. Returns -1 if solution file doesn't exist
        sortedpartmodel = ",".join(sorted(partmodels.split(",")))
        sortedpartmodelname = "{" + sortedpartmodel + "}"
        modeldirname = "{" + modeldir + "}"

        templmodeldir = os.path.join(self.topfolder, "TemplateSolutions", sortedpartmodel)
        self.mrsol = [None,None,None,None,None,None,None,None,None,[],[]]

        workpath = os.path.join(self.topfolder, "MR", modeldir)
        workpath = os.path.relpath(workpath, self.topfolder)
        stridername = calclabel + modeldirname + partmodels
        rootname = os.path.join(workpath, stridername)
# get LLG values from text files that holds float values rather than the int values in the sol files
        CorrCoeffname = os.path.join(workpath,"CalcCC_" + modeldirname + partmodels + ".txt")
        CorrCoeffname2 = os.path.join(workpath,"CalcCC_RNP_VRMS.txt")
        CorrCoeffname3 = os.path.join(workpath,"CalcCC__" + modeldirname + partmodels + ".txt")
        realLLGsVRMSfname = os.path.join(workpath,"LLG_RNP_VRMS" + modeldirname +  partmodels + ".txt")
        realLLGsVRMSfname2= os.path.join(workpath,"LLGsFromRNP_VRMS.txt")
        realLLGsVRMSfname3 = os.path.join(workpath,"LLG_RNP_VRMS.txt")
        CorrCoeffullresfname = os.path.join(workpath,"CalcCC_FullResRNP_VRMS_FullRes.txt")
        realLLGsVRMSfullresfname = os.path.join(workpath,"LLG_FullRes_RNP_VRMS.txt")
        realLLGsfname = os.path.join(workpath,"LLGsFrom" + stridername + ".txt")
        mrsolfname = ""
# override default value if supplied
        if solutionfname != "":
            fname = os.path.join(workpath, solutionfname)
            if os.path.exists(fname):
                mrsolfname = fname

            wildcard = "".join([e + "." for e in  solutionfname.split(".")[:-1]])[:-1] + "CalcCC_*.txt"
            cname = glob.glob(os.path.join(workpath, wildcard))
            CorrCoeffname = ""
            if len(cname)>0:
                CorrCoeffname = cname[0]
        else:
            fname = os.path.join(workpath, calclabel + modeldirname +  partmodels + ".sol")
            if os.path.exists(fname):
                mrsolfname = fname
            fname = os.path.join(workpath, "RNP_VRMS" + modeldirname +  partmodels + ".sol")
            if os.path.exists(fname):
                mrsolfname = fname
            fname = os.path.join(workpath, "RNP_VRMS.sol")
            if os.path.exists(fname):
                mrsolfname = fname

# allocate storage for the LLG float values
# 1st and 2nd are arrays for each MR solution. 3rd is the single value from RNP
# 4th and 5th are arrays for correlation coefficients
        self.mrsol[3] = [[None],[None],[None], None, None, None, None, [None]]
# store phaser solution in the 0th entry of the mrsol array
# initially solution files were given without vrms refinement.
# using RNP_VRMS.sol provides the vrms values in addition to the phaser solution
        if IsSolFileValid(mrsolfname):
            mrparser= phaser.test_phaser_parsers.SolutionFileParser(open(mrsolfname))
            self.mrsol[0] = mrparser.get_dot_sol()
        else:
            return -1 # otherwise bail out

# open file with numbers of reflections
        FTFfname = rootname + ".FTF_Scores.txt"
        if os.path.exists(FTFfname) == False:
            fnames = glob.glob(os.path.join(workpath, "*.FTF_Scores.txt"))
            if len(fnames) > 0:
                FTFfname = fnames[0]

        if os.path.exists(FTFfname):
            FTFfile = open(FTFfname,"r")
            FTFstr = FTFfile.read()
            FTFfile.close()
# so we can calculate LLG per reflections
            self.mrsol[2] = re.search("Number of selected reflections:\s+([0-9]+)", FTFstr).group(1)

# get ELLGs if present
        fname = os.path.join(workpath,"ELLG_*_%s.txt" %modeldir)
        ellgfname = glob.glob(fname)[0] if len(glob.glob(fname)) > 0 else ""
        ELLGtbl = ""
        if os.path.exists(ellgfname):
            ELLGtbl = open(ellgfname, "r").read()

        templfname = os.path.join(templmodeldir, "RNP" + sortedpartmodelname \
         + ".superposed.sol")
        realtemplLLGfname = os.path.join(templmodeldir, "LLGsFromRNP"
         + sortedpartmodelname + ".txt")
        templCorrCoeffname = os.path.join(templmodeldir, "CCsFromRNP"
         + sortedpartmodelname + ".txt")
# read those LLG float values from the text files
        if os.path.exists(realLLGsfname):
            realLLGs = open(realLLGsfname, "r").read()
            self.mrsol[3][0] = eval(realLLGs)

        if os.path.exists(realLLGsVRMSfname):
            realLLGsVRMS = open(realLLGsVRMSfname, "r").read()
            self.mrsol[3][1] = eval(realLLGsVRMS)
        else:
            if os.path.exists(realLLGsVRMSfname2):
                realLLGsVRMS = open(realLLGsVRMSfname2, "r").read()
                self.mrsol[3][1] = eval(realLLGsVRMS)
            else:
                if os.path.exists(realLLGsVRMSfname3):
                    realLLGsVRMS = open(realLLGsVRMSfname3, "r").read()
                    self.mrsol[3][1] = eval(realLLGsVRMS)

        if os.path.exists(realLLGsVRMSfullresfname):
            realLLGsfullresVRMS = open(realLLGsVRMSfullresfname, "r").read()
            self.mrsol[3][2] = eval(realLLGsfullresVRMS)

        if os.path.exists(realtemplLLGfname):
            realtemplLLG = open(realtemplLLGfname, "r").read()
            self.mrsol[3][3] = eval(realtemplLLG)[0]

        if os.path.exists(CorrCoeffname):
            CorrCoef = open(CorrCoeffname, "r").read()
            self.mrsol[3][4] = eval(CorrCoef)
        else: # pick up alternative CC file only if using default filename
            if solutionfname == "":
                if os.path.exists(CorrCoeffname2):
                    CorrCoef = open(CorrCoeffname2, "r").read()
                    self.mrsol[3][4] = eval(CorrCoef)
                else:
                    if os.path.exists(CorrCoeffname3):
                        CorrCoef = open(CorrCoeffname3, "r").read()
                        self.mrsol[3][4] = eval(CorrCoef)
        if os.path.exists(CorrCoeffullresfname):
            CorrCoeffullres = open(CorrCoeffullresfname, "r").read()
            self.mrsol[3][5] = eval(CorrCoeffullres)

        if os.path.exists(templCorrCoeffname):
            templCorrCoef = open(templCorrCoeffname, "r").read()
            self.mrsol[3][6] = eval(templCorrCoef)

        if IsSolFileValid(templfname):
            templparser= phaser.test_phaser_parsers.SolutionFileParser(file(templfname))
        else:
            return -1
        templsols = templparser.get_dot_sol()
        self.mrsol[1] = templsols # provide the annotation and RMS for the template solution

# Provided an mr solution exist see if we have combined RNP solutions of two component models.
# Do this by asserting the number of pdbids in partmodels is 2
        if len(self.mrsol[0]) > 0 and len(partmodels.split(",")) > 1:
# gather results for combined components as many times as there are solutions
            ncombsols = len(self.mrsol[0])
            for i in range(ncombsols):
                combsolfname = os.path.join(workpath,"Combined_%d_%s.sol" %(i,modeldir))
                combllgfname = os.path.join(workpath,"Combined_%d_LLG_RNP_VRMS%s.txt" %(i,modeldirname))
                # hack for having given file wrong name during calculations
                if os.path.exists(combllgfname) == False:
                    combllgfname = os.path.join(workpath,"Combined_%d_LLG_RNP_VRMS{%s.txt" %(i,modeldir))

                if IsSolFileValid(combsolfname):
                    mrparser = phaser.test_phaser_parsers.SolutionFileParser(open(combsolfname))
                    combllg = eval(open(combllgfname,"r").read())[0]
                    self.mrsol[10].append((mrparser.get_dot_sol()[0], combllg))
                else:
                    self.mrsol[10].append((None, None))
# We want the vrms values for the refinement with the full set of reflections
# Get these by storing the solution of the this refinement into the 7th entry of the mrsol array
        solfname = os.path.join(workpath, "RNP_VRMS_FullRes.sol")
        if IsSolFileValid(solfname):
            mrparser= phaser.test_phaser_parsers.SolutionFileParser(file(solfname))
            self.mrsol[7] = mrparser.get_dot_sol() # auxiliary variable so we can read annotations etc. from it
# Want Fsol and Bsol if these were calculated
# Open the BsolFsolRNPcalc_1RLH_2D16_A.txt file. TargetPDBid isn't defined here so we use a wildcard
        Fsolfname = os.path.join(workpath, "BsolFsolRNPcalc.sol")
        if IsSolFileValid(Fsolfname):
            mrparser= phaser.test_phaser_parsers.SolutionFileParser(file(Fsolfname))
            self.mrsol[8] = mrparser.get_dot_sol() # auxiliary variable so we can read annotations etc. from it

# create EnsembleDefinitionDict of model pdbs using ensemble names as keywords
# get the pdbfile names from the mrinput file
        infile = open(templmodeldir + os.path.sep + "RNP_MRinput.txt","r")
        templinput = infile.read()
        infile.close()
        pdbs = re.findall("ENSEMBLE\s+(.*?)\s+PDB\s+(.*?)\s+IDENTITY\s+(.+[^\r])(\r*)",
          templinput, re.DOTALL|re.MULTILINE|re.IGNORECASE) # to get rid of any \r character
        ed = template.EnsembleDefinition()
        for i in range(0,len(pdbs)):
            modelfname = os.path.join(self.topfolder, pdbs[i][1])
            ed.define(pdbs[i][0],{modelfname : 100})
# get mtz file
        m = templinput.find("HKLIN")
        n = templinput.find("\n",m)
        mtzname = re.findall("HKLIN\s+(\S+)", templinput[m:n], re.MULTILINE)[0]
# define crystallographic matches from spacegroup info in mtz and appropriate resolutions
# for the template matching by reading the dimensions of the models
        fname = os.path.join(self.topfolder,mtzname)
        fname = CalcCCFromMRsolutions.PosixSlashFilePath(fname)
        fname = CalcCCFromMRsolutions.RecaseFilename(fname)

        #em = template.EquivalentMatcher.from_mtz(fname)
# get all matched template solutions
        #solmatch = em.equivalents_of(templsols[0], self.mrsol[0], ed)
        #return len(solmatch)
        modelfname = CalcCCFromMRsolutions.PosixSlashFilePath(modelfname)
        matches = AreMatching(fname, [templfname], mrsolfname, modelfname)
# mrsol[9] is the ELLGtable values read as a string. Convert to a python list
        if ELLGtbl != "":
            for k, line in enumerate(ELLGtbl.split("\n")):
                if k == 0:
                    continue
                llst = line.split("\t")
                if len(llst) < 9:
                    continue
# if template solution was wrong evaluate correctness of ELLG solutions by also comparing with the mrsolution
                ellgsolfname = os.path.join(workpath,"ELLG_MRcalcs_%d.sol" %int(float(llst[0])))
                #mrresolution = float(llst[8])
                #ellgmatches = AreMatching(fname, [templfname, mrsolfname], ellgsolfname,
                #  modelfname, mrresolution)
                ellgmatches = AreMatching(fname, [templfname, mrsolfname], ellgsolfname,
                  modelfname)
                #print "ellgmatches = " + str(ellgmatches)
# append result to llst
                llst.append(int(ellgmatches[0]))
                self.mrsol[9].append(llst)

        return matches[0]



    def NoticeCompletedPhaserRun(self,workdir, partmodels,
                     nPartSolWithThisStrategy):
        bPartSolWithThisStrategy = True
        if nPartSolWithThisStrategy < 1:
            bPartSolWithThisStrategy = False

        if self.mylock != None:
            self.mylock.acquire()

        completedruns = open(self.completedrunfname,"a")
        completedruns.write("%s {%s} %s\n" %(workdir, partmodels,
                     str(bPartSolWithThisStrategy)))
        completedruns.close()

        if self.mylock != None:
            self.mylock.release()



    def PhaserRanPartModelsBefore(self,founddir,partmodels,bsolved,doneruns=""):
        if self.completedrunfname != "" and os.path.exists(self.completedrunfname) == False:
            return False

        if self.mylock != None:
            self.mylock.acquire()

        if doneruns == "":
            completedruns = open(self.completedrunfname,"r")
            doneruns = completedruns.read()
            completedruns.close()

        if self.mylock != None:
            self.mylock.release()
# assuming the file looks like
# 1I1A_D,3GIZ_H,1NC2_A {1I1A_D} True
# 1W72_H,1NC2_A,1I1A_D {1W72_H} False
# 1I1A_D,1W72_H,1NC2_A {1I1A_D,1W72_H} True
#
        bsolved[0] = False
        m = doneruns.find("{" + partmodels + "}", 0)
        if m > 0:
# note what calculation was used for searching on the partial model
            n = doneruns.rfind("\n",0,m)
            if n == -1 and m > 0:
                n = 0  # found it in the very first line
            #print "partmodels= %s m= %d, n= %d, doneruns[n:m]= %s" % (partmodels,m,n,doneruns[n:m])
            founddir[0] = doneruns[n:m].split()[0]

            n = doneruns.find("\n",m)
        # find the bool value from "{1I1A_D} True"
            if doneruns[m:n].split(" ")[1] == "True":
                bsolved[0] = True
            else:
                bsolved[0] = False

            return True
        else:
            return False
