#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      oeffner
#
# Created:     05/04/2011
# Copyright:   (c) oeffner 2011
# Licence:     <your licence>
#-------------------------------------------------------------------------------
#!/usr/bin/env python

import os, re, sys, shutil, glob
import cStringIO
from iotbx import pdb, mtz
import scitbx.math.euler_angles
from phaser import AlterOriginSymmate
from phaser import *
#from phaser import SimpleFileProperties
import phaser.test_phaser_parsers
from phenix.command_line import get_cc_mtz_mtz
from phenix.command_line import get_cc_mtz_pdb


# Copying HomologySearches to bixcluster didn't completely preserve file name case.
# So we need to identify file paths but in a case insensitive manner before opening files
def RecaseFilename(fname, mylock=None):
    if sys.platform == "win32": # as filenames are case insensitive
        return fname
# in case we're invoked by a separate thread we must protect os.chdir which acts globally
    if mylock != None:
        mylock.acquire()

    dirs = fname.split(os.sep)
    curdir = os.getcwd()
    recasedpath = ""
    if dirs[0] == "": # for unix paths
        os.chdir(os.sep)
        recasedpath = os.sep
    #
    for dir in dirs:
        files = glob.glob("*")
        m = []
        for file in files:
            #print "file= %s, dir = %s " %(file, dir)
            m = re.findall(dir,file,re.IGNORECASE)
            if m != [] and len(dir) == len(file):
                recasedpath = os.path.join(recasedpath, m[0])
                #print "m[0], file= " + m[0] + ", " + file
                break
        #
        if dir != dirs[-1] and dir != "" and m != []:
            #print "m= %s, dir= %s" %(str(m), dir)
            #os.chdir(file)
            os.chdir(m[0])
    #
    os.chdir(curdir)
    if mylock != None:
        mylock.release()

    return recasedpath



def PosixSlashFilePath(fpath):
    if sys.platform != "win32":
        mstr = ""
        for c in fpath:
            if c == "\\":
                mstr += "/"
            else:
                mstr += c

        return mstr

    else:
        return fpath




def ShiftMRsols(solfname, outfname):
    mrparser = phaser.test_phaser_parsers.SolutionFileParser(file(solfname))
    mrsols = mrparser.get_dot_sol()

    newsolstr = ""
    for mrsol in mrsols:
        nd = []
        for eulerfrac in mrsol.KNOWN:
            fraccoord = eulerfrac.getFracT()
        # remove any integer unitcell shifts by computing fraccoord modulo 1
            frac_shift = (fraccoord[0] % 1, fraccoord[1] % 1, fraccoord[2] % 1)
            eulers = eulerfrac.getEuler()
            bfac = eulerfrac.getBfac()
            modlid = eulerfrac.getModlid()
            nd.append(phaser.mr_ndim(modlid, eulers, True, frac_shift, bfac, False, False, False))
        set1 = phaser.mr_set(mrsol.ANNOTATION, nd, [], 0, 0, 0, 0, 0, 0, 0, 0,0, 0, [], phaser.MapCoefs(), phaser.map_str_float1D() )
        newsolstr += set1.unparse()
        newsolstr += "\n"

    mfile = open(outfname,"w")
    mfile.write(newsolstr)
    mfile.close()



def RealizeSoluPDB(xtalsym, pdbfname, euler, frac, outfname):
    pdbmrsol = pdb.input(file_name= pdbfname)
    rot = scitbx.math.euler_angles.zyz_matrix(float(euler[0]), float(euler[1]), float(euler[2]))
    trans = (float(frac[0]), float(frac[1]), float(frac[2]))
    mrsolhiearchy = pdbmrsol.construct_hierarchy().deep_copy()
    modelatoms = mrsolhiearchy.atoms()
    # do the rotation in cartesian space
    rotatomsites = rot * modelatoms.extract_xyz()
    ucell = xtalsym.unit_cell()
    # get into fractional space
    fracatomsites = ucell.fractionalize(sites_cart= rotatomsites )
    # position and rotate pdb to the mr solution
    mrsolsites = fracatomsites + trans
    # cast back to cartesian coordinates
    modelatoms.set_xyz(ucell.orthogonalize(sites_frac= mrsolsites))
    lastpdbfname = outfname
    mrsolpdbfile = open(lastpdbfname, "w")
    mrsolpdbfile.write(mrsolhiearchy.as_pdb_string())
    mrsolpdbfile.close()




def getCC(mtz1, fname2, temp):
    print "Calculating CC between %s and %s" %(mtz1, fname2)
    dmpstr = cStringIO.StringIO()
    if os.path.exists(temp): # clean up just in case a previous calculation crashed
        shutil.rmtree(temp)
    if fname2[-4:] == ".mtz":
        cmdargs = ["mtz_1="+ mtz1, "mtz_2=" + fname2,
         "temp_dir=" + temp]
        myobj = get_cc_mtz_mtz.get_cc_mtz_mtz(cmdargs, quiet=True, out=dmpstr)
        contents = dmpstr.getvalue()
        return (float(myobj.final_cc), 0.0)
    else:
        cmdargs = ["mtz_in="+ mtz1, "pdb_in=" + fname2,
          "temp_dir=" + temp]
        myobj = get_cc_mtz_pdb.get_cc_mtz_pdb(cmdargs, quiet=False, out=dmpstr)
        contents = dmpstr.getvalue()
        return (float(myobj.found_overall), float(myobj.found_region))



def CreateZeroRNPcycleMap(datrun, rano, rootname, pdbfname, targseqnames, modelrmsd):
    mtzmapname = rootname + ".1.mtz"
    print "Making map %s from 0 cycle RNP of %s" %(mtzmapname, pdbfname)
    #if os.path.exists(mtzmapname):
    #    return mtzmapname + " exists already.\n"

    rnptargetinput = InputMR_RNP()
    rnptargetinput.setSPAC_HALL(datrun.getSpaceGroupHall())
    rnptargetinput.setCELL6(datrun.getUnitCell())
    rnptargetinput.setREFL(rano.getMiller(),rano.getCorrectedF(),rano.getCorrectedSIGF())

    rnptargetinput.setROOT(rootname)
    rnptargetinput.setJOBS(1)
    rnptargetinput.setXYZO(False) # only want the map
    pdbfname = RecaseFilename(pdbfname)

    rnptargetinput.addENSE_PDB_RMS("RNP0cycle", pdbfname, modelrmsd)
    rnptargetinput.addSOLU_ORIG_ENSE("RNP0cycle")
    for i in range(len(targseqnames)):
        rnptargetinput.addCOMP_PROT_SEQ_NUM(targseqnames[i], 1)

    rnptargetinput.setMUTE(True)
# 0 macrocycles, no refinement
    rnptargetinput.setMACM_PROT("OFF")

    rnptarget = runMR_RNP(rnptargetinput)
    if not rnptarget.Success():
        return rnptarget.ErrorName() + " TargetPDB RNP ERROR: " + rnptarget.ErrorMessage() + "\n"
        #raise Exception, m
    else:
        return ""



def RNP_CombinedComponents(targetpdbid, MRfolder, calclabel, workdir, partmodels):
    stroutput = ""
    calcdir = os.getcwd()
    mrinput = open(os.path.join(MRfolder, calclabel + "MRinput.txt"), "r").read()
    mtzfname = re.findall(r"^HKLIN\s+(\S+)", mrinput, re.MULTILINE)[0] # to get rid of any \r character
    # if filepath generated on windows but now running on unix then change \ to /
    mtzfname = mtzfname.replace("\\", os.path.sep)

    mtzcol = re.findall(r"^LABIN\s*F\s*=\s*(\S*)\s*SIGF\s*=\s*(\S+)\s*", mrinput, re.MULTILINE)
    myinput = InputMR_DAT()
    mtzfname= RecaseFilename(mtzfname)

    mtzobj = mtz.object(mtzfname)
    xtalsym = mtzobj.crystals()[0].crystal_symmetry()

    myinput.setHKLI(mtzfname)
    myinput.setLABI(mtzcol[0][0],mtzcol[0][1])
    myinput.setMUTE(True)
    datrun = runMR_DAT(myinput)

    if datrun.Success():
        solfname = calclabel + "{" + workdir + "}" + partmodels + ".sol"
        fname = os.path.join(MRfolder, solfname)
        mstr = "\nCalculating RNP of combined components from %s" %solfname
        stroutput += mstr
        print mstr
        if os.path.exists(fname) == False:
            mstr = "Error: %s doesn't exist.\n" %fname
            stroutput += mstr
            print mstr
            return stroutput

        solfname= RecaseFilename(fname)
# filename for mrsol file where fractional coordinates have been cast into unitcell near origo
        #newsolfname = os.path.join(os.path.split(fname)[0], "shift_" + os.path.split(fname)[1])
        #ShiftMRsols(fname, newsolfname)

        mrparser = phaser.test_phaser_parsers.SolutionFileParser(file(solfname))
        #mrparser = phaser.test_phaser_parsers.SolutionFileParser(file(newsolfname))
        mrsols = mrparser.get_dot_sol()
# get ensemble name and sequence file name from some phaser input file
        MRpdbens = re.findall(r"^ENSEMBLE\s+(\S+)\s+PDB\s+(\S+)\s+IDENTITY\s+(\S+)\s+",
          mrinput, re.MULTILINE)
        seqfnames = re.findall(r"^COMPOSITION PROTEIN SEQUENCE\s+(\S+)\s+NUM.+",
          mrinput, re.MULTILINE)
        for seqfname in seqfnames:
            seqfname = seqfname.replace("\\", os.path.sep)
            seqfname= RecaseFilename(seqfname)

        myano = InputANO()
        myano.setSPAC_HALL(datrun.getSpaceGroupHall())
        myano.setCELL6(datrun.getUnitCell())
        myano.setREFL(datrun.getMiller(),datrun.getFobs(),datrun.getSigFobs())
        myano.setMUTE( True )
        rano = phaser.runANO( myano )
        if not rano.Success():
            mstr = rano.ErrorName() + "ANO ERROR: " + rano.ErrorMessage() + "\n"
            stroutput += mstr
            return stroutput

        enspdbs = []
        avgseqid = 0.0
        for ensemble in MRpdbens:
            modelfname = ensemble[1].replace("\\", os.path.sep).strip() # to get rid of any \r character
            modelfname= RecaseFilename(modelfname)
            enspdbs.append([ensemble[0],[modelfname]])
            avgseqid += float(ensemble[2])
# an average sequence identity is fine when doing VRMS RNP with no rotation and translation
        avgseqid /= len(MRpdbens)

        n = len(mrsols)
        for k, sol in enumerate(mrsols):
            soltxt = sol.unparse()
            lmodelfname = AlterOriginSymmate.RealizePhaserSolutions([soltxt], xtalsym, enspdbs, "Combined_", MRfolder)
            modelfname = os.path.join(MRfolder, lmodelfname[0])
            mstr = "\nDoing RNP of %s, %d out of %d" %(modelfname, k+1, n)
            stroutput += mstr
            print mstr

            myinput = InputMR_RNP()
            myinput.setJOBS(6)
            myinput.addENSE_PDB_ID("MR_Combined", modelfname, avgseqid)
# add solution at origin
            myinput.addSOLU_ORIG_ENSE("MR_Combined")
# setup RNP refinement of the MR model
            myinput.setSPAC_HALL(datrun.getSpaceGroupHall())
            myinput.setCELL6(datrun.getUnitCell())
            myinput.setREFL(rano.getMiller(),rano.getCorrectedF(),rano.getCorrectedSIGF())

            for seqfname in seqfnames:
                myinput.addCOMP_PROT_SEQ_NUM(seqfname, 1)

            myinput.setMUTE(True)
# RNP vrms refinement, no rotation or translation refinement
            myinput.addMACM(False, False, False, True )
            root = os.path.join(MRfolder, "Combined_" + str(k) + "_" + partmodels)
            myinput.setROOT(root)
            myinput.setXYZO(False)
            myinput.setHKLO(False)

            run = runMR_RNP(myinput)
            if run.Success():
    #save result to log and sol files
                logfname = root + ".log"
                logfile = open(logfname,"w")
                logfile.write(run.logfile())
                logfile.close()
                rnpsolfname = root + ".sol"
                solfile = open(rnpsolfname,"w")
                solfile.write(run.getDotSol().unparse())
                solfile.close()
                fname = os.path.join(MRfolder,"Combined_" + str(k) + "_LLG_RNP_VRMS{" + partmodels + "}.txt")
                llgfile = open(fname,"w")
                llgs =[]
                for (i,llg) in enumerate(run.getValues()):
                    llgs.append(llg)
                    mstr = "llg= %s\n" %llg
                    #print stroutput
                    stroutput += mstr
                    print mstr,

                llgfile.write(str(llgs))
                llgfile.close()
            else:
                mstr = run.ErrorName() + "Model RNP ERROR: " + run.ErrorMessage() + "\n"
                stroutput += mstr

            os.remove(modelfname)

        stroutput +=  "\nDone with RNP of %s" %modelfname

    else:
        mstr = datrun.ErrorName() + " MR_DAT ERROR: " + datrun.ErrorMessage() + "\n"
        #raise Exception, m
        stroutput += mstr

    return stroutput





def CalcCCFromMRsolution(targetpdbid, MRfolder, calclabel, workdir, partmodels,
  bCalcCC = False, mylock=None):
    stroutput = ""
    calcdir = os.getcwd()
    mrinput = open(os.path.join(MRfolder, calclabel + "MRinput.txt"), "r").read()
    mtzfname = re.findall(r"^HKLIN\s+(\S+)", mrinput, re.MULTILINE)[0] # to get rid of any \r character
    # if filepath generated on windows but now running on unix then change \ to /
    mtzfname = mtzfname.replace("\\", os.path.sep)

    mtzcol = re.findall(r"^LABIN\s*F\s*=\s*(\S*)\s*SIGF\s*=\s*(\S+)\s*", mrinput, re.MULTILINE)
    myinput = InputMR_DAT()
    mtzfname= RecaseFilename(mtzfname, mylock)
    mtzobj = mtz.object(mtzfname)
    xtalsym = mtzobj.crystals()[0].crystal_symmetry()

    myinput.setHKLI(mtzfname)
    myinput.setLABI(mtzcol[0][0],mtzcol[0][1])
    myinput.setMUTE(True)
    datrun = runMR_DAT(myinput)

    if datrun.Success():
        solfname = calclabel + "{" + workdir + "}" + partmodels + ".sol"
        fname = os.path.join(MRfolder, solfname)
        mstr = "Calculating LLGs from %s\n" %solfname
        stroutput += mstr
        print mstr
        if os.path.exists(fname) == False:
            mstr = "Error: %s doesn't exist.\n" %fname
            stroutput += mstr
            print mstr
            return stroutput

        fname= RecaseFilename(fname, mylock)
# filename for mrsol file where fractional coordinates have been cast into unitcell near origo
        #newsolfname = os.path.join(os.path.split(fname)[0], "shift_" + os.path.split(fname)[1])
        #ShiftMRsols(fname, newsolfname)

        mrparser = phaser.test_phaser_parsers.SolutionFileParser(file(fname))
        #mrparser = phaser.test_phaser_parsers.SolutionFileParser(file(newsolfname))
        mrsols = mrparser.get_dot_sol()
# get ensemble name and sequence file name from some phaser input file
        MRpdbens = re.findall(r"^ENSEMBLE\s+(\S+)\s+PDB\s+(\S+)\s+IDENTITY\s+(\S+)\s+",
          mrinput, re.MULTILINE)
        seqfnames = re.findall(r"^COMPOSITION PROTEIN SEQUENCE\s+(\S+)\s+NUM.+",
          mrinput, re.MULTILINE)
# because strings are immutable we iterate with int index
# rather than list elements in order to change the strings
        for i in range(len(seqfnames)):
            seqfnames[i] = PosixSlashFilePath(seqfnames[i])
            seqfnames[i] = RecaseFilename(seqfnames[i], mylock)

        myano = InputANO()
        myano.setSPAC_HALL(datrun.getSpaceGroupHall())
        myano.setCELL6(datrun.getUnitCell())
        myano.setREFL(datrun.getMiller(),datrun.getFobs(),datrun.getSigFobs())
        myano.setMUTE( True )
        rano = phaser.runANO( myano )
        if not rano.Success():
            mstr = rano.ErrorName() + "ANO ERROR: " + rano.ErrorMessage() + "\n"
            stroutput += mstr
            return stroutput

# make map of targetpdb with its own mtz file by doing RNP with 0 cycles with an origin solution
        rnptargetrootname = targetpdbid + "_map"
        targetpdb = targetpdbid + ".pdb"
        stroutput += CreateZeroRNPcycleMap(datrun, rano, rnptargetrootname,
          RecaseFilename(targetpdb, mylock), seqfnames, 0.1)

# setup RNP refinement of the MR model
        myinput = InputMR_RNP()
        myinput.setSPAC_HALL(datrun.getSpaceGroupHall())
        myinput.setCELL6(datrun.getUnitCell())
        myinput.setREFL(rano.getMiller(),rano.getCorrectedF(),rano.getCorrectedSIGF())

        rootname = os.path.join(MRfolder, "RNP_VRMS{" + workdir + "}" + partmodels)
        myinput.setROOT(rootname)
# refine all solutions in one go
        myinput.setSOLU(mrsols)
        #if bfullres :
        #    myinput.setRESO_HIGH(0.0) # use all reflections
        myinput.setJOBS(1)
        for ensemble in MRpdbens:
            modelfname = ensemble[1].replace("\\", os.path.sep).strip() # to get rid of any \r character
            modelfname= RecaseFilename(modelfname, mylock)
            myinput.addENSE_PDB_ID(ensemble[0], modelfname, float(ensemble[2]))

        for seqfname in seqfnames:
            myinput.addCOMP_PROT_SEQ_NUM(seqfname, 1)

        myinput.setMUTE(True)
# RNP vrms refinement, no rotation or translation refinement
        myinput.addMACM(False, False, False, True )
        #myinput.addMACM(False, False, False, False )
        #myinput.setVERB(True)
        #myinput.setDEBU(True)
        #del(run)

        run = runMR_RNP(myinput)

        if run.Success():
#save result to log and sol files
            logfname = rootname + ".log"
            logfile = open(logfname,"w")
            logfile.write(run.logfile())
            logfile.close()
            rnpsolfname = rootname + ".sol"
            solfile = open(rnpsolfname,"w")
            solfile.write(run.getDotSol().unparse())
            solfile.close()
            fname = os.path.join(MRfolder,"LLG_RNP_VRMS{" + workdir + "}" + partmodels + ".txt")
            llgfile = open(fname,"w")
            llgs =[]
            for (i,llg) in enumerate(run.getValues()):
                llgs.append(llg)
                mstr = "llg= %s\n" %llg
                #print stroutput
                stroutput += mstr
                print mstr

            llgfile.write(str(llgs))
            llgfile.close()
        else:
            msg = run.ErrorName() + "Model RNP ERROR: " + run.ErrorMessage() + "\n"
            print msg
            return msg
# Set up Correlation Coefficient calculation
        rnpsols = run.getDotSol()

        myCCs = []

        if not bCalcCC:
            return

        mstr += "Calculating CCs of %s with %d solutions\n" %(fname, len(rnpsols))
        stroutput += mstr
        print mstr

        for (i, rnpsol) in enumerate(rnpsols):
            myinput = InputMR_LLG()
            myinput.setSPAC_HALL(datrun.getSpaceGroupHall())
            myinput.setCELL6(datrun.getUnitCell())
            myinput.setREFL(rano.getMiller(),rano.getCorrectedF(),rano.getCorrectedSIGF())
            root = os.path.join(MRfolder, "CalcCC_")
            mtzfname = root + ".1.mtz"
            myinput.setROOT(root)
            myinput.setXYZO(False)
            myinput.setHKLO(True)
            myinput.setJOBS(1)
            myinput.setMUTE(True)
            #myinput.setVERB(True)
            solu = phaser.mr_solution([rnpsol]) # convert this rnpsol into a string
            myinput.setSOLU(solu)

            lastmodelname = ""
            lastsolcomponent = ""
            lastvrms = 0.0

            solstr = rnpsol.unparse()
            MRsolens = re.findall("SOLU 6DIM ENSE\s+(.+)\s+(EULER.+)\s+(FRAC.+)\s+BFAC.+", solstr, re.MULTILINE)
            for k, enseulerfrac in enumerate(MRsolens):
                vrms = rnpsol.VRMS.values()[k][0]
# find filename of the pdb file with this ensemble name from the MR input file
                for ens in MRpdbens:
                    if ens[0] == enseulerfrac[0]:
                        modelfname = ens[1].replace("\\", os.path.sep).strip() # to get rid of any \r character
                        modelfname= RecaseFilename(modelfname, mylock)
                        break
                # prepare for refinement by adding all components
                myinput.addENSE_PDB_RMS(enseulerfrac[0], modelfname, vrms)
                # store details of the last component
                lastmodelname = modelfname
                lastenseulerfrac = enseulerfrac
                lastvrms = vrms
# realize pdbfile solution with the last component only
            eulers = re.findall(r"EULER\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)",
              lastenseulerfrac[1], re.MULTILINE)
            fracs = re.findall(r"FRAC\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)",
              lastenseulerfrac[2], re.MULTILINE)
            lastpdbfname = os.path.join(MRfolder,"lastens.pdb")
            RealizeSoluPDB(xtalsym, lastmodelname, eulers[0], fracs[0], lastpdbfname)
# set up a temp folder
            CCtemp = ""
            tmpdir = targetpdbid + "_" + workdir + "_"+ partmodels
            if "TMP" in os.environ:
                CCtemp = os.path.join(os.environ["TMP"], tmpdir)
            if "TEMP" in os.environ:
                CCtemp = os.path.join(os.environ["TEMP"], tmpdir)
            #if os.path.exists("/scratch"):
            #    CCtemp = os.path.join("/scratch", tmpdir) # telemachus cluster solution
            if CCtemp == "":
                CCtemp = os.path.join(os.environ["HOME"], "CCTEMP", tmpdir) #last resort
# calculate CC between target and pdbfile of last component
            CCpdb = getCC(rnptargetrootname + ".1.mtz", lastpdbfname, CCtemp)
            stroutput += "CCpdb of last component: %f, %f\n" %(CCpdb[0], CCpdb[1])
# create map of last component from RNP 0 cycles with phaser
            lastroot = os.path.join(MRfolder,"lastens")
            stroutput += CreateZeroRNPcycleMap(datrun, rano, lastroot,
              RecaseFilename(lastpdbfname, mylock), seqfnames, lastvrms)
# get CC with that map and target map
            CClast = getCC(rnptargetrootname + ".1.mtz", lastroot+ ".1.mtz", CCtemp)
            stroutput += "CCmap of last component:  %f, %f\n" %(CClast[0], CClast[1])

            for seqfname in seqfnames:
                myinput.addCOMP_PROT_SEQ_NUM(seqfname, 1)

            llgrun = runMR_LLG(myinput)
# get CC of map of all components against target map
            if llgrun.Success():
                CCall = getCC(rnptargetrootname + ".1.mtz", mtzfname, CCtemp)
                stroutput += "CC of all components:  %f, %f\n" %(CCall[0], CCall[1])
# append all CCs to list
                myCCs.append((CCall[0], CCall[1], CClast[0], CClast[1], CCpdb[0], CCpdb[1]))

            else:
                mstr = llgrun.ErrorName() + " MR_LLG ERROR: " + llgrun.ErrorMessage() + "\n"
                #raise Exception, m
                stroutput += mstr
                print mstr
                #return stroutput

            fname = root + "{" + workdir + "}" + partmodels + ".txt"
            CCfile = open(fname,"w")
            CCfile.write(str(myCCs))
            CCfile.close()

            if os.path.exists(mtzfname):
                try:
                    os.remove(mtzfname)
                except Exception, m:
                    stroutput += m

            if os.path.exists(CCtemp): # clean up just in case a previous calculation crashed
                try:
                    shutil.rmtree(CCtemp)
                except Exception, m:
                    stroutput += m

    else:
        mstr = datrun.ErrorName() + " MR_DAT ERROR: " + datrun.ErrorMessage() + "\n"
        #raise Exception, m
        stroutput += mstr

    return stroutput




def CalcCCFromSCOP_MRcalcs(selectedpdbfname, scoppdbsfname, calcdir):
    mfile = open(selectedpdbfname,"r")
    selectedpdbs = eval(mfile.read())
    mfile.close()

    mfile = open(scoppdbsfname,"r")
    scoppdbs = eval(mfile.read())
    mfile.close()

    logfname = os.path.join(calcdir, os.path.basename(selectedpdbfname) + ".log")

    n = 0
    l = len(selectedpdbs)
    for (n,pdbs) in enumerate(selectedpdbs):
        mstr = ""
        for scoppdb in scoppdbs:
            if scoppdb[0].lower().find(pdbs[0].lower()) > -1:
                scopid = scoppdb[1]
# only want directories named with SCOP fold id
                if scopid == "UnSCOPed":
                    foldID = "UnSCOPed"
                else:
                    foldID = scopid.split(".")[0] + "." + scopid.split(".")[1]

                #foldID = scopid.split(".")[0] + "." + scopid.split(".")[1]
                fold_targetpdb = os.path.join(calcdir,foldID,pdbs[0])
                if not os.path.exists(fold_targetpdb):
                    fold_targetpdb = os.path.join(calcdir,foldID,pdbs[0].lower())

                BLASTtxtchainfname =  os.path.join(fold_targetpdb, "Strider" + pdbs[0] + "_BLASTchain_ids.txt")
                psearches = eval(open(BLASTtxtchainfname,"r").read())

                mstr += "CalcCCFromMRcalcs %s, %s, %d. out of %d\n" %(fold_targetpdb, pdbs[0], n, l)

                for psearch in psearches:
                    workdir = psearch[1][-1] # the last element in ['2WBJ_C0', '2WBJ_C0,1NFD_B0']
                    for partmodels in psearch[1]:

                        MRfolder = os.path.join(fold_targetpdb,"MR", workdir)

                        try:
                            os.chdir(fold_targetpdb)
                            mstr += "Calculating CCs from %s\n" %solfname
                            mstr += CalcCCFromMRsolution(pdbs[0], MRfolder, "Strider", workdir,
                              partmodels, bCalcCC = True)

                        except Exception, m:
                            mstr += "Error in %s, %s, %s\n" %(selectedpdbfname, scoppdbsfname, m)
                            #raise

                        finally:
                            os.chdir(calcdir)

        logfile = open(logfname,"a")
        logfile.write(mstr)
        logfile.close()

    mstr = "Done with " + selectedpdbfname + "\n"
    logfile = open(logfname,"a")
    logfile.write(mstr)
    logfile.close()




def CalcRNP_FromMRcalcs(pdbid, calcdir):
    #mfile = open(pdbsfname,"r")
    #lpdbs = eval(mfile.read())
    #mfile.close()

    #logfname = os.path.join(calcdir, os.path.basename(pdbsfname) + ".log")
    logfname = os.path.join(calcdir, os.path.basename(pdbid) + ".log")

    #n = 0
    #l = len(lpdbs)
    #for (n,pdb) in enumerate(lpdbs):

    mstr = ""
    #foldID = scopid.split(".")[0] + "." + scopid.split(".")[1]
    fold_targetpdb = os.path.join(calcdir,pdbid)
    if not os.path.exists(fold_targetpdb):
        fold_targetpdb = os.path.join(calcdir,pdbid.lower())

    BLASTtxtchainfname = os.path.join(fold_targetpdb, "Strider" + pdbid + "_BLASTchain_ids.txt")
    if os.path.exists(BLASTtxtchainfname):
        psearches = eval(open(BLASTtxtchainfname,"r").read())

        mstr += "CalcCCFromMRcalcs %s, %s\n" %(fold_targetpdb, pdbid)

        for psearch in psearches:
            workdir = psearch[1][-1] # the last element in ['2WBJ_C0', '2WBJ_C0,1NFD_B0']
            #for partmodels in psearch[1]:
            partmodels = workdir # on this occassion we're only interested in multicomponent refinements

            MRfolder = os.path.join(fold_targetpdb,"MR", workdir)

            try:
                os.chdir(fold_targetpdb)
                #print "MRfolder= %s, partmodels = %s" %(MRfolder, partmodels)
                #RNP_CombinedComponents(pdbid, MRfolder, "Strider", workdir, partmodels)
                mstr += CalcCCFromMRsolution(pdbid, MRfolder, "Strider", workdir,
                  partmodels, bCalcCC = True)

            except Exception, m:
                mstr += "Error in %s, %s\n" %(fold_targetpdb, m)
                print "Error in %s, %s\n" %(fold_targetpdb, m)
                #raise

            finally:
                os.chdir(calcdir)

    else:
        mstr += "Error: %s doesn't exist" %BLASTtxtchainfname
        print "Error: %s doesn't exist" %BLASTtxtchainfname

    logfile = open(logfname,"a")
    logfile.write(mstr)
    mstr = "Done with " + fold_targetpdb + "\n"
    logfile.write(mstr)
    logfile.close()




if __name__=="__main__":
    if len(sys.argv) > 3:
        CalcCCFromSCOP_MRcalcs(sys.argv[1], sys.argv[2], sys.argv[3])
    else:
        CalcRNP_FromMRcalcs(sys.argv[1], sys.argv[2])

    print "Done for today"


