<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pack_c.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>pack_c.h</h1><div class="fragment"><pre>00001 <font class="comment">/* Some general defines: */</font>
00002 
00003 
00004 <font class="preprocessor">#define PACKIDENTIFIER "\nCCP4 packed image, X: %04d, Y: %04d\n"</font>
00005 <font class="preprocessor"></font><font class="comment">/* This string defines the start of a packed image. An image file is scanned</font>
00006 <font class="comment">   until this string is encountered, the size of the unpacked image is </font>
00007 <font class="comment">   determined from the values of X and Y (which are written out as formatted</font>
00008 <font class="comment">   ascii numbers), and the packed image is expected to start immediately after</font>
00009 <font class="comment">   the null-character ending the string. */</font>
00010 
00011 <font class="preprocessor">#define V2IDENTIFIER "\nCCP4 packed image V2, X: %04d, Y: %04d\n"</font>
00012 <font class="preprocessor"></font><font class="comment">/* This string defines the start of a packed image. An image file is scanned</font>
00013 <font class="comment">   until this string is encountered, the size of the unpacked image is </font>
00014 <font class="comment">   determined from the values of X and Y (which are written out as formatted</font>
00015 <font class="comment">   ascii numbers), and the packed image is expected to start immediately after</font>
00016 <font class="comment">   the null-character ending the string. */</font>
00017 
00018 <font class="preprocessor">#define PACKBUFSIZ BUFSIZ</font>
00019 <font class="preprocessor"></font><font class="comment">/* Size of internal buffer in which the packed array is stored during transit</font>
00020 <font class="comment">   form an unpacked image to a packed image on disk. It is set to the size</font>
00021 <font class="comment">   used by the buffered io-routines given in &lt;stdio.h&gt;, but it could be </font>
00022 <font class="comment">   anything. */</font>
00023 
00024 <font class="preprocessor">#define DIFFBUFSIZ 16384L</font>
00025 <font class="preprocessor"></font><font class="comment">/* Size of the internal buffer in which the differences between neighbouring </font>
00026 <font class="comment">   pixels are stored prior to compression. The image is therefore compressed </font>
00027 <font class="comment">   in DIFFBUFSIZ chunks. Decompression does not need to know what DIFFBUFSIZ</font>
00028 <font class="comment">   was when the image was compressed. By increasing this value, the image</font>
00029 <font class="comment">   can be compressed into a packed image which is a few bytes smaller. Do</font>
00030 <font class="comment">   not decrease the value of DIFFBUFSIZ below 128L. */</font>
00031  
00032 <font class="preprocessor">#define BYTE char</font>
00033 <font class="preprocessor"></font><font class="comment">/* BYTE is a one byte integer. */</font>
00034 
00035 <font class="preprocessor">#define WORD short int</font>
00036 <font class="preprocessor"></font><font class="comment">/* WORD is a two-byte integer. */</font>
00037 
00038 <font class="preprocessor">#define LONG int</font>
00039 <font class="preprocessor"></font><font class="comment">/* LONG is a four byte integer. */</font>
00040 <font class="comment">/* Dave Love 5/7/94: using `int' gets you 4 bytes on the 32-bit Unix</font>
00041 <font class="comment">   (and VAX) systems I know of and also on (64-bit) OSF/1 Alphas which</font>
00042 <font class="comment">   have 64-bit longs.  (This definition previously used `long'.) */</font>
00043 
00044 
00045 
00046 <font class="comment">/******************************************************************************/</font>
00047 
00048 <font class="comment">/* Some usefull macros used in the code of this sourcefile: */</font>
00049 
00050 
00051 <font class="preprocessor">#define max(x, y) (((x) &gt; (y)) ? (x) : (y)) </font>
00052 <font class="preprocessor"></font><font class="comment">/* Returns maximum of x and y. */</font>
00053 
00054 <font class="preprocessor">#define min(x, y) (((x) &lt; (y)) ? (x) : (y)) </font>
00055 <font class="preprocessor"></font><font class="comment">/* Returns minimum of x and y. */</font>
00056 
00057 <font class="preprocessor">#undef abs                      </font><font class="comment">/* avoid complaint from DEC C, at least */</font>
00058 <font class="preprocessor">#define abs(x) (((x) &lt; 0) ? (-(x)) : (x))</font>
00059 <font class="preprocessor"></font><font class="comment">/* Returns the absolute value of x. */</font>
00060 
00061 <font class="comment">/* Used to be 'static const LONG' but const declaration gives trouble on HPs */</font>
00062 <font class="preprocessor">#ifndef SKIP_SETBITS</font>
00063 <font class="preprocessor"></font><font class="keyword">static</font> LONG setbits[33] =
00064                          {0x00000000L, 0x00000001L, 0x00000003L, 0x00000007L,
00065                           0x0000000FL, 0x0000001FL, 0x0000003FL, 0x0000007FL,
00066                           0x000000FFL, 0x000001FFL, 0x000003FFL, 0x000007FFL,
00067                           0x00000FFFL, 0x00001FFFL, 0x00003FFFL, 0x00007FFFL,
00068                           0x0000FFFFL, 0x0001FFFFL, 0x0003FFFFL, 0x0007FFFFL,
00069                           0x000FFFFFL, 0x001FFFFFL, 0x003FFFFFL, 0x007FFFFFL,
00070                           0x00FFFFFFL, 0x01FFFFFFL, 0x03FFFFFFL, 0x07FFFFFFL,
00071                           0x0FFFFFFFL, 0x1FFFFFFFL, 0x3FFFFFFFL, 0x7FFFFFFFL,
00072                           0xFFFFFFFFL};
00073 <font class="comment">/* This is not a macro really, but I've included it here anyway. Upon indexing,</font>
00074 <font class="comment">   it returns a LONG with the lower (index) number of bits set. It is equivalent</font>
00075 <font class="comment">   to the following macro:</font>
00076 <font class="comment">     #define setbits(n) (((n) == 32) : ((1L &lt;&lt; (n)) - 1) : (-1L)) </font>
00077 <font class="comment">   Indexing the const array should usually be slightly faster. */</font>
00078 <font class="preprocessor">#endif</font>
00079 <font class="preprocessor"></font>
00080 <font class="preprocessor">#define shift_left(x, n)  (((x) &amp; setbits[32 - (n)]) &lt;&lt; (n))</font>
00081 <font class="preprocessor"></font><font class="comment">/* This macro is included because the C standard does not properly define a </font>
00082 <font class="comment">   left shift: on some machines the bits which are pushed out at the left are</font>
00083 <font class="comment">   popped back in at the right. By masking, the macro prevents this behaviour.</font>
00084 <font class="comment">   If you are sure that your machine does not pops bits back in, you can speed</font>
00085 <font class="comment">   up the code insignificantly by taking out the masking. */</font>
00086 
00087 <font class="preprocessor">#define shift_right(x, n) (((x) &gt;&gt; (n)) &amp; setbits[32 - (n)])</font>
00088 <font class="preprocessor"></font><font class="comment">/* See comment on left shift. */</font>
00089 
00090 
00091 
00092 <font class="comment">/******************************************************************************/</font>
00093 
00094 
00095 
00096 
00097 <font class="comment">/* Functions required for packing: */</font>
00098 
00099 <font class="preprocessor">#if defined (PROTOTYPE)</font>
00100 <font class="preprocessor"></font><font class="keywordtype">void</font> v2pack_wordimage_c(WORD *img, <font class="keywordtype">int</font> x, <font class="keywordtype">int</font> y, <font class="keywordtype">char</font> *filename);
00101 <font class="comment">/* Pack image 'img', containing 'x * y' WORD-sized pixels into 'filename'.</font>
00102 <font class="comment">   This function generates Version 2 images! */</font>
00103 
00104 <font class="keywordtype">void</font> v2pack_longimage_c(LONG *img, <font class="keywordtype">int</font> x, <font class="keywordtype">int</font> y, <font class="keywordtype">char</font> *filename);
00105 <font class="comment">/* Pack image 'img', containing 'x * y' LONG-sized pixels into 'filename'. </font>
00106 <font class="comment">   This function generates Version 2 images! */</font>
00107 
00108 
00109 <font class="comment">/* Functions required for unpacking: */</font>
00110 
00111 
00112 <font class="keywordtype">void</font> readpack_word_c(WORD *img, <font class="keywordtype">char</font> *filename);
00113 <font class="comment">/* Unpacks packed image from 'filename' into the WORD-array 'img'. Scans the</font>
00114 <font class="comment">   file defined by 'filename' until the PACKIDENTIFIER is found, then unpacks</font>
00115 <font class="comment">   starting from there. */</font>
00116 
00117 <font class="keywordtype">void</font> readpack_long_c(LONG *img, <font class="keywordtype">char</font> *filename);
00118 <font class="comment">/* Unpacks packed image from 'filename' into the LONG-array 'img'. Scans the</font>
00119 <font class="comment">   file defined by 'filename' until the PACKIDENTIFIER is found, then unpacks</font>
00120 <font class="comment">   starting from there. */</font>
00121 
00122 <font class="keywordtype">void</font> imsiz_c(<font class="keywordtype">char</font> *filename, LONG *x, LONG *y);
00123 <font class="comment">/* Determines the size of the the packed image "filename" after unpacking. The</font>
00124 <font class="comment">   dimensions are returned in x and y. */</font>
00125 
00126 <font class="preprocessor">#endif  </font><font class="comment">/* (PROTOTYPE) */</font>
00127 
</pre></div>
</body>
</html>
