<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ccp4_parser.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.13.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>ccp4_parser.c File Reference</h1>Functions to read in and "parse" CCP4-style keyworded input. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;float.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include "<a class="el" href="ccp4__parser_8h-source.html">ccp4_parser.h</a>"</code><br>
<code>#include "<a class="el" href="ccp4__errno_8h-source.html">ccp4_errno.h</a>"</code><br>
<code>#include "<a class="el" href="ccp4__sysdep_8h-source.html">ccp4_sysdep.h</a>"</code><br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a0" doxytag="ccp4_parser.c::CPARSER_ERRNO"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSER_ERRNO</b>(n)&nbsp;&nbsp;&nbsp;(CCP4_ERR_PARS | (n))</td></tr>
<tr><td nowrap align=right valign=top><a name="a1" doxytag="ccp4_parser.c::CPARSERR_Ok"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_Ok</b>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top><a name="a2" doxytag="ccp4_parser.c::CPARSERR_MaxTokExceeded"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_MaxTokExceeded</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top><a name="a3" doxytag="ccp4_parser.c::CPARSERR_AllocFail"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_AllocFail</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td nowrap align=right valign=top><a name="a4" doxytag="ccp4_parser.c::CPARSERR_NullPointer"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_NullPointer</b>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td nowrap align=right valign=top><a name="a5" doxytag="ccp4_parser.c::CPARSERR_LongLine"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_LongLine</b>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td nowrap align=right valign=top><a name="a6" doxytag="ccp4_parser.c::CPARSERR_CantOpenFile"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_CantOpenFile</b>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td nowrap align=right valign=top><a name="a7" doxytag="ccp4_parser.c::CPARSERR_NoName"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_NoName</b>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td nowrap align=right valign=top><a name="a8" doxytag="ccp4_parser.c::CPARSERR_ExpOverflow"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_ExpOverflow</b>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td nowrap align=right valign=top><a name="a9" doxytag="ccp4_parser.c::CPARSERR_ExpUnderflow"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_ExpUnderflow</b>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td nowrap align=right valign=top><a name="a10" doxytag="ccp4_parser.c::CPARSERR_MatToSymop"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_MatToSymop</b>&nbsp;&nbsp;&nbsp;9</td></tr>
<tr><td nowrap align=right valign=top><a name="a11" doxytag="ccp4_parser.c::CPARSERR_SymopToMat"></a>
#define&nbsp;</td><td valign=bottom><b>CPARSERR_SymopToMat</b>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>CCP4PARSERARRAY *&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a13">ccp4_parse_start</a> (const int maxtokens)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a14">ccp4_parse_end</a> (CCP4PARSERARRAY *parsePtr)</td></tr>
<tr><td nowrap align=right valign=top><a name="a15" doxytag="ccp4_parser.c::ccp4_parse_init_token"></a>
int&nbsp;</td><td valign=bottom><b>ccp4_parse_init_token</b> (const CCP4PARSERARRAY *parsePtr, const int itok)</td></tr>
<tr><td nowrap align=right valign=top><a name="a16" doxytag="ccp4_parser.c::ccp4_parse_reset"></a>
int&nbsp;</td><td valign=bottom><b>ccp4_parse_reset</b> (CCP4PARSERARRAY *parsePtr)</td></tr>
<tr><td nowrap align=right valign=top><a name="a17" doxytag="ccp4_parser.c::ccp4_parse_delimiters"></a>
int&nbsp;</td><td valign=bottom><b>ccp4_parse_delimiters</b> (CCP4PARSERARRAY *parsePtr, const char *delim, const char *nulldelim)</td></tr>
<tr><td nowrap align=right valign=top><a name="a18" doxytag="ccp4_parser.c::ccp4_parse_comments"></a>
int&nbsp;</td><td valign=bottom><b>ccp4_parse_comments</b> (CCP4PARSERARRAY *parsePtr, const char *comment_chars)</td></tr>
<tr><td nowrap align=right valign=top><a name="a19" doxytag="ccp4_parser.c::ccp4_parse_maxmin"></a>
int&nbsp;</td><td valign=bottom><b>ccp4_parse_maxmin</b> (CCP4PARSERARRAY *parsePtr, const double max_exponent, const double min_exponent)</td></tr>
<tr><td nowrap align=right valign=top><a name="a20" doxytag="ccp4_parser.c::ccp4_parse"></a>
int&nbsp;</td><td valign=bottom><b>ccp4_parse</b> (const char *line, CCP4PARSERARRAY *parser)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a21">ccp4_parser</a> (char *line, const int nchars, CCP4PARSERARRAY *parser, const int print)</td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a22">ccp4_keymatch</a> (const char *keyin1, const char *keyin2)</td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a23">strtoupper</a> (char *str1, const char *str2)</td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a24">strtolower</a> (char *str1, const char *str2)</td></tr>
<tr><td nowrap align=right valign=top><a name="a25" doxytag="ccp4_parser.c::strmatch"></a>
int&nbsp;</td><td valign=bottom><b>strmatch</b> (const char *str1, const char *str2)</td></tr>
<tr><td nowrap align=right valign=top><a name="a26" doxytag="ccp4_parser.c::charmatch"></a>
int&nbsp;</td><td valign=bottom><b>charmatch</b> (const char character, const char *charlist)</td></tr>
<tr><td nowrap align=right valign=top><a name="a27" doxytag="ccp4_parser.c::doublefromstr"></a>
int&nbsp;</td><td valign=bottom><b>doublefromstr</b> (const char *str, const double max_exp, const double min_exp, double *valuePtr, double *intvaluePtr, int *intdigitsPtr, double *frcvaluePtr, int *frcdigitsPtr, double *expvaluePtr, int *expdigitsPtr)</td></tr>
<tr><td nowrap align=right valign=top>ccp4_symop&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a28">symop_to_rotandtrn</a> (const char *symchs_begin, const char *symchs_end)</td></tr>
<tr><td nowrap align=right valign=top>const char *&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a29">symop_to_mat4</a> (const char *symchs_begin, const char *symchs_end, float *rot)</td></tr>
<tr><td nowrap align=right valign=top><a name="a30" doxytag="ccp4_parser.c::symop_to_mat4_err"></a>
int&nbsp;</td><td valign=bottom><b>symop_to_mat4_err</b> (const char *symop)</td></tr>
<tr><td nowrap align=right valign=top><a name="a31" doxytag="ccp4_parser.c::mat4_to_rotandtrn"></a>
ccp4_symop&nbsp;</td><td valign=bottom><b>mat4_to_rotandtrn</b> (const float rsm[4][4])</td></tr>
<tr><td nowrap align=right valign=top><a name="a32" doxytag="ccp4_parser.c::rotandtrn_to_symop"></a>
char *&nbsp;</td><td valign=bottom><b>rotandtrn_to_symop</b> (char *symchs_begin, char *symchs_end, const ccp4_symop symop)</td></tr>
<tr><td nowrap align=right valign=top><a name="a33" doxytag="ccp4_parser.c::rotandtrn_to_mat4"></a>
void&nbsp;</td><td valign=bottom><b>rotandtrn_to_mat4</b> (float rsm[4][4], const ccp4_symop symop)</td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a34">mat4_to_symop</a> (char *symchs_begin, char *symchs_end, const float rsm[4][4])</td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="ccp4__parser_8c.html#a35">mat4_to_recip_symop</a> (char *symchs_begin, char *symchs_end, const float rsm[4][4])</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions to read in and "parse" CCP4-style keyworded input.
<p>

<p>

<p>
 <dl compact><dt><b>
Author: </b><dd>
Peter Briggs </dl><dl compact><dt><b>
Date: </b><dd>
April 2001</dl><hr><h2>Function Documentation</h2>
<a name="a22" doxytag="ccp4_parser.c::ccp4_keymatch"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ccp4_keymatch </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>keyin1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>keyin2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Test whether two keywords are identical. Keywords are identical if  they are the same up to the first four characters, independent of case. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>keyin1</em>&nbsp;</td><td>
keyword 1. </td></tr>
<tr><td valign=top><em>keyin2</em>&nbsp;</td><td>
keyword 2. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
1 if keywords keyin1 and keyin2 are "identical", 0 otherwise. </dl>    </td>
  </tr>
</table>
<a name="a14" doxytag="ccp4_parser.c::ccp4_parse_end"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ccp4_parse_end </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CCP4PARSERARRAY *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>parsePtr</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cleans up a CCP4PARSEARRAY after being used by ccp4_parse/ ccp4_parser functions. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>parsePtr</em>&nbsp;</td><td>
pointer to a CCP4PARSERARRAY structure </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
0 on completion </dl>    </td>
  </tr>
</table>
<a name="a13" doxytag="ccp4_parser.c::ccp4_parse_start"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CCP4PARSERARRAY* ccp4_parse_start </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>maxtokens</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialise a CCP4PARSERARRAY to be used in subsequent calls to ccp4_parser routines. The calling function must supply the maximum  number of tokens on a line (including continuation lines). <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>maxtokens</em>&nbsp;</td><td>
maximum number of tokens on a line </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
pointer to a new CCP4PARSERARRAY structure </dl>    </td>
  </tr>
</table>
<a name="a21" doxytag="ccp4_parser.c::ccp4_parser"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int ccp4_parser </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>line</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>n</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>CCP4PARSERARRAY *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>parser</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>print</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The main function for parsing lines, either supplied or read from stdin. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>line</em>&nbsp;</td><td>
pointer to a null-terminated string of characters, forming the input to be processed. On input can either be an empty  string ("") which forces reading from stdin, or contain characters  to be processed. On output "line" will be overwritten with the actual input line. </td></tr>
<tr><td valign=top><em>n</em>&nbsp;</td><td>
maximum number of characters that can be read into "line" i.e. the size of "line" in memory. </td></tr>
<tr><td valign=top><em>parser</em>&nbsp;</td><td>
pointer to a CCP4PARSERARRAY structure which will be used to hold the results of processing the input line. </td></tr>
<tr><td valign=top><em>print</em>&nbsp;</td><td>
flag controlling echoing of input lines to stdout. print=0: suppress echoing of lines to stdout. Otherwise echoing is  turned on. </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
Number of tokens found. </dl>    </td>
  </tr>
</table>
<a name="a35" doxytag="ccp4_parser.c::mat4_to_recip_symop"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* mat4_to_recip_symop </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>symchs_begin</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>symchs_end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rsm</em>[4][4]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert symmetry operator as matrix to string in reciprocal space notation. This is Charles' version of symtr. Note that translations are held in elements [*][3] and [3][3] is set to 1.0 <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>symchs_begin</em>&nbsp;</td><td>
pointer to beginning of string </td></tr>
<tr><td valign=top><em>symchs_end</em>&nbsp;</td><td>
pointer to end of string (i.e. last character is *(symchs_end-1) ) </td></tr>
<tr><td valign=top><em>rsm</em>&nbsp;</td><td>
4 x 4 matrix operator </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
pointer to beginning of string </dl>    </td>
  </tr>
</table>
<a name="a34" doxytag="ccp4_parser.c::mat4_to_symop"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* mat4_to_symop </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>symchs_begin</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>symchs_end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const float&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rsm</em>[4][4]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert symmetry operator as matrix to string. This is Charles' version of symtr. Note that translations are held in elements [*][3] and [3][3] is set to 1.0 <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>symchs_begin</em>&nbsp;</td><td>
pointer to beginning of string </td></tr>
<tr><td valign=top><em>symchs_end</em>&nbsp;</td><td>
pointer to end of string (i.e. last character is *(symchs_end-1) ) </td></tr>
<tr><td valign=top><em>rsm</em>&nbsp;</td><td>
4 x 4 matrix operator </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
pointer to beginning of string </dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="ccp4_parser.c::strtolower"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* strtolower </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>str1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>str2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert string to lowercase. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>&nbsp;</td><td>
On exit str1 will contain lowercased copy of str2 </td></tr>
<tr><td valign=top><em>str2</em>&nbsp;</td><td>
Input string </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
str1 </dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="ccp4_parser.c::strtoupper"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* strtoupper </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>str1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>str2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert string to uppercase. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str1</em>&nbsp;</td><td>
On exit str1 will contain uppercased copy of str2 </td></tr>
<tr><td valign=top><em>str2</em>&nbsp;</td><td>
Input string </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
str1 </dl>    </td>
  </tr>
</table>
<a name="a29" doxytag="ccp4_parser.c::symop_to_mat4"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* symop_to_mat4 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>symchs_begin</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>symchs_end</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>float *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>rot</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert symmetry operator as string to matrix. This is Charles' version of symfr. Note that translations are held in elements [*][3] and [3][3] is set to 1.0 <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>symchs_begin</em>&nbsp;</td><td>
pointer to beginning of string </td></tr>
<tr><td valign=top><em>symchs_end</em>&nbsp;</td><td>
pointer to end of string (i.e. last character is *(symchs_end-1) ) </td></tr>
<tr><td valign=top><em>rot</em>&nbsp;</td><td>
4 x 4 matrix operator </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
NULL on error, final position pointer on success </dl>    </td>
  </tr>
</table>
<a name="a28" doxytag="ccp4_parser.c::symop_to_rotandtrn"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ccp4_symop symop_to_rotandtrn </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>symchs_begin</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>symchs_end</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert symmetry operator as string to ccp4_symop struct. <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>symchs_begin</em>&nbsp;</td><td>
pointer to beginning of string </td></tr>
<tr><td valign=top><em>symchs_end</em>&nbsp;</td><td>
pointer to end of string (i.e. last character is *(symchs_end-1) ) </td></tr>
</table>
</dl><dl compact><dt><b>
Returns: </b><dd>
pointer to ccp4_symop struct </dl>    </td>
  </tr>
</table>

</body>
</html>
