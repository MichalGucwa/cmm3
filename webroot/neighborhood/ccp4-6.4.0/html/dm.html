<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>CCP4 Program Suite</TITLE>
</HEAD>
<BODY>

<!-- ::INDEX_INFO::DM::Supported::Density Modification - Molecular Averaging::density modification package:::::::: -->

<H1>DM (CCP4: Supported Program)</H1>
<H2>NAME</H2>
<B>dm </B>
- density modification package, release 2.1, 04/04/00 

<H2>SYNOPSIS</H2>

<P><B>dm HKLIN</B> <I>foo.mtz</I> <B>HKLOUT</B> <I>bar.mtz</I> [ <B>SOLIN</B>
<I>foo.msk</I> ] [ <B>SOLOUT</B> <I>bar.msk</I> ] [ <B>NCSIN1</B> <I>foo1.msk</I>
[ <B>NCSIN2 ...</B> ] ] [ <B>NCSOUT</B> <I>foobar.msk</I> ] [ <B>VUOUT</B> <I>foobar.vu</I> ]<BR> 
[<A HREF="#keywords">Keyworded input</A>]

<H2>REFERENCE</H2>

<UL>
<P><!-- KEEP startreferencelist --></P>

<LI>K. Cowtan (1994), Joint CCP4 and ESF-EACBM Newsletter on Protein Crystallography,
31, p34-38. </LI>
<!-- KEEP endreferencelist -->
</UL>

<H2><A NAME="description"></A>DESCRIPTION</H2>

<P>`dm' is a package which applies real space constraints based on known
features of a protein electron density map in order to improve the approximate
phasing obtained from experimental sources. Various information can be
applied, including such diverse elements as the following (see the <A HREF="#mode">MODE</A>
keyword): </P>

<DL>
<DT>SOLV</DT>

<DD> Solvent flattening (<A HREF="#reference8">reference [8]</A>) </DD>

<DT>HIST</DT>

<DD> Histogram mapping (<A HREF="#reference9">reference [9]</A>) </DD>

<DT>MULT</DT>

<DD> Multi-resolution modification </DD>

<DT>AVER</DT>

<DD> NCS averaging (<A HREF="#reference2">reference [2]</A>, <A HREF="#reference6">reference [6]</A>) </DD>

<DT>SKEL</DT>

<DD> Skeletonisation (<A HREF="#reference1">reference [1]</A>, <A HREF="#reference7">reference [7]</A>) </DD>

<DT>SAYR</DT>

<DD> Sayre's equation (<A HREF="#reference5">reference [5]</A>, <A HREF="#reference9">reference [9]</A>) </DD>
</DL>

<P>The program has many phase extension schemes and phase
weighting/combination modes, which are selected by the appropriate
choice of keywords. The combination mode is determined by the <A HREF="#combine">COMBINE</A>
keyword, if this keyword is omitted then the program runs in
perturbation-gamma mode.</P>

<P>Calculation of scale and B-factor for the data are automatic. This is
performed by comparison with an empirically derived database of map variance
at different resolutions, and is more reliable than the conventional Wilson
plot. </P>

<P>Non-crystallographic symmetry averaging can be performed for both proper
and improper symmetries, and different NCS averaging operations can be
applied to different parts of the protein. (Thanks to Dave Schuller for
his help with this). Input masks may be on any grid and axis order. In
the case of a single averaging domain, if no averaging mask is input then
a mask can be generated automatically. </P>

<P>Skeletonisation is by the core-tracing algorithm of Swanson (<A HREF="#reference7">reference [7]</A>). This
is faster than Greer's algorithm and allows adjustment of the skeletonisation
parameters without recalculating the skeleton. As a result the skeletonisation
calculation is rendered largely automatic. </P>

<H2>`dm' RECIPES</H2>

<P>As a starting point, I used the following recipes. If averaging is available,
use it and run for at least 10 cycles: </P>

<PRE>SOLC &lt;solc&gt;
MODE SOLV HIST MULT AVER
COMBINE PERT
NCYCLE 20
AVER REFI
 ...
LABIN ...
LABOUT ...
</PRE>

<p>For averaging calculations where there is a great deal of phase
extension to be performed (<EM>e.g.</EM> from 6.0&#197; to 2.5&#197;), use more cycles
and specify a phase extension scheme:

<PRE>SOLC &lt;solc&gt;
MODE SOLV HIST AVER
COMBINE PERT
SCHEME RES FROM 6.0
NCYCLE 200
AVER REFI
 ...
LABIN ...
LABOUT ...
</PRE>

<P>or </P>

<P>If averaging is not available, you may want to use <A HREF="#ncycle_auto">NCYCLE AUTO</A> to
prevent the phase bias and overweighting. Alternatively, you can run
the calculation for more cycles, but be aware that the FOMs will be
badly overestimated:
</P>

<PRE>SOLC &lt;solc&gt;
MODE SOLV HIST MULT
COMBINE PERT
NCYCLE AUTO
LABIN ...
LABOUT ...
</PRE>

<P><A HREF="#mode_hist">HISTogram matching</A> should ALWAYS be used. <A HREF="#mode_mult">MULTi-resolution
modification</A> is new, but also worth using. </P>

<H3>Free Indicators</H3>

<P>There are two Free indicators that `dm' can use. The first is the
density modification Free-R (defined in the same way as the refinement
Free-R).  This is calculated in the Free-Sim and Omit
modes. Unfortunately, while effective for refinement, it is a poor
indicator of the progress of density modification, however it can be
used in many cases to identify the correct enantiomorph. A better
indicator (due to J. P. Abrahams) is the real-space-free-residual.
This is calculated by omitting two small spheres of protein and
solvent from the density modification. The flatness of the solvent
sphere and the histogram fit in the protein sphere provide a better
indication of progress.
</P>

<H2><A NAME="files"></A>INPUT/OUTPUT FILES</H2>

<H3>HKLIN </H3>

<P>Input mtz file - This should contain the conventional (CCP4) asymmetric
unit of data (see <A HREF="cad.html">CAD</A>). </P>

<H3>HKLOUT</H3>

<P>Output mtz file. </P>

<H3><A NAME="solin"></A>SOLIN</H3>

<P>Input solvent mask - This overrides the automatic Wang mask determination.
The input mask can have any grid and axis ordering, and may have any extent
from the protein region of a single asymmetric unit to the whole cell.
</P>

<P>Alternatively, a map may be input on the SOLIN channel. In this map
any grid points set to 1.0 are considered protein, grid points set to 0.0
are solvent, and grid points set to -1.0 are considered to be neither.
By constructing an appropriate input mask it is possible to perform solvent
flattening and histogram matching without suppressing any heavy atom density.
</P>

<H3><A NAME="solout"></A>SOLOUT</H3>

<P>Output solvent mask - This will be on the program grid with default
axis order, and will cover the whole unit cell. </P>

<H3>NCSIN&lt;i&gt;</H3>

<P>Input NCS averaging masks - These are used with the <A HREF="#mode_aver">AVER</A> option. The
input masks can have any grid or axis ordering, and may cover a single
monomer or the whole multimer. </P>

<P>If an NCS averaging mask is not input, the program will compute it
with an automatic procedure, when there is only one domain involved.
Auto-NCS masking depends on knowing how many monomers form a closed
symmetry group. This can be specified with the NCSMASK NMER keywords, 
or the program will attempt to estimate it for simple cases. If you do not
supply a value, check the value the program estimates carefully. </P>

<H3>NCSOUT</H3>

<P>If the averaging mask is calculated automatically, or is being
refined (<A HREF="#ncsmask_update">NCSMASK UPDATE</A> keyword) it may be output in this file. </P>

<H3>VUOUT</H3>

<P>When Non-Crystallographic Symmetry is present, its symmetry elements,
i.e. axis and points, can be visualised using XtalView or O. If the
keyword VUOUT is followed by a ``.vu'' file, the program writes out a
file that can be used in XtalView to view the NCS elements. If the
keyword is followed by a ``.o'' file the output can be visualised using
the program O. Default is to .vu files. </P>

<FONT COLOR=red><H3>Using <TT>dm</TT> after <TT>SHARP</TT></H3>

<P><TT>SHARP</TT> is probably the best source of phasing
for density modification.  However, if you wish to run <TT>dm</TT> after
<TT>SHARP</TT> you should first turn off the <TT>Solomon</TT> option.</P>

<P><TT>Solomon</TT> produces excellent maps, and so often having run
<TT>SHARP</TT> and <TT>Solomon</TT> you will not want to use
<TT>dm</TT> at all. However, <TT>Solomon</TT> produces badly
overestimated FOM's (typically 0.9 - 0.95), which while they do not
damage the maps, effectively cripple any further density modification
(or for that matter any phased maximum-likelihood refinement
calculation).</P>

<P>(Since the FOM is based on an estimate of the error in the phases, a
high FOM implies that the phases are correct and therefore should not
be modified by any subsequent procedure. Thus further density
modification will hardly change the maps, and ML-refinement will be
badly biased by the errors in the starting phases.)</P></FONT>

<H2><A NAME="keywords"></A>KEYWORDS</H2>

<P>Input is keyworded. Available keywords are:
<A HREF="#average">AVERAGE</A>, <A HREF="#combine">COMBINE</A>,
<A HREF="#grid">GRID</A>, <A HREF="#labin">LABIN</A>, <A HREF="#labout">LABOUT</A>,
<A HREF="#mode">MODE</A>, <A HREF="#ncsmask">NCSMASK</A>, <A HREF="#ncycle">NCYCLE</A>,
<A HREF="#realfree">REALFREE</A>, <A HREF="#resolution">RESOLUTION</A>,
<A HREF="#scale">SCALE</A>, <A HREF="#scheme">SCHEME</A>, <A HREF="#skel">SKEL</A>,
<A HREF="#solc">SOLC</A>, <A HREF="#solmask">SOLMASK</A>.</P>

<p>In addition, the following optional keywords control the data harvesting
functionality: <a href="#general_pname"><b>PNAME</b></a>, <a href="#general_dname"><b>DNAME</b></a>,
<a href="#general_private"><b>PRIVATE</b></a>, <a href="#general_usecwd"><b>USECWD</b></a>,
<a href="#general_rsize"><b>RSIZE</b></a>, <a href="#general_noharvest"><b>NOHARVEST</b></a>


<H2><A NAME="keywords_basic"></A>BASIC KEYWORDS</H2>
<P>(SOLC and MODE are compulsory) </P>

<div align=center><table width=90% border=0><tr><td bgcolor=#a0ffa0>

<H3><A NAME="mode"></A>MODE [SOLV] [HIST] [MULT] [AVER] [SKEL] [SAYR] [NO????]</H3>

<P>Select the calculation to be performed: </P>

<DL>
<DT><A NAME="mode_solv"></A>SOLV</DT>

<DD> Solvent flattening (recommended)</DD>

<DT><A NAME="mode_hist"></A>HIST</DT>

<DD> Histogram mapping (recommended)</DD>

<DT><A NAME="mode_mult"></A>MULT</DT>

<DD> Multi-resolution application of solv/hist (recommended)</DD>

<DT><A NAME="mode_aver"></A>AVER</DT>

<DD> Non-crystallographic symmetry averaging (recommended when available)</DD>

<DT><A NAME="mode_skel"></A>SKEL</DT>

<DD> Skeletonisation </DD>

<DT><A NAME="mode_sayr"></A>SAYR</DT>

<DD> Sayre's equation </DD>

<DT><A NAME="mode_nohist"></A>NOHIST</DT>

<DD> Histogram matching is enabled by default. However there may exist
some very exceptional cases where histogram matching is
undesirable. Such cases should first be established by careful trials
with synthetic data or solved structures. Histogram matching is more
often disabled through ignorance or superstition. It is disabled by
adding the NOHIST subkeyword.</DD>
</DL>

<H3><A NAME="solc"></A>SOLC &lt;solc&gt; [MEAN &lt;solvval&gt; &lt;protval&gt;]</H3>

<DL>
<DT>&lt;solc&gt;</DT>

<DD> = solvent content for scaling. <b>Always input the correct
solvent content here to ensure correct scaling</b>. To vary the masked
volume, do not alter the SOLC card, rather use the <A HREF="#solmask_frac">SOLMASK FRAC</A>
keyword. 0.0=all protein, 1.0=all solvent. </DD>

<DT><A NAME="solc_mean"></A>MEAN &lt;solvval&gt; &lt;protval&gt;</DT>

<DD> - used to set mean density for solvent and protein regions. This affects
scaling and density modification. <BR>
&lt;solvval&gt; = mean density in solvent region. <BR>
&lt;protval&gt; = mean density in protein region. <BR>
(defaults 0.32, 0.43 electrons per cubic angstrom) </DD>
</DL>

<H3><A NAME="ncycle"></A>NCYCLE &lt;ncycle&gt; | AUTO</H3>

<P>Number of cycles of phase extension to perform. </P>

<DL>
<DT>&lt;ncycle&gt;</DT>

<DD> = Number of cycles over which to perform phase extension. Use 10 cycles
for a quick result, try more (20-100) but check the free-R factor. (Free-Sim
mode). </DD>

<DT><A NAME="ncycle_auto"></A>AUTO</DT>

<DD> = Run until the real-space-free residual stops decreasing, then
stop.  This is used in the Perturbation/Omit combination modes when no
averaging is available and running the calculation for too many cycles
can cause phase bias and overweighting. </DD>
</DL>

<P>(defaults &lt;ncycles&gt;=10) </P>

<H3><A NAME="combine"></A>COMBINE  PERT | OMIT [ NOCOMBINE ] [ RESTORE &lt;restorewt&gt; ]</H3>

<DL>
<DT><A NAME="combine_pert"></A>PERT</DT>

<DD> Use perturbation gamma correction for bias reduction. This is the
recommended mode for all calculations, and is selected by default.</DD>

<DT><A NAME="combine_omit"></A>OMIT</DT>

<DD> Use reflection omit combination for bias reduction. This method
is much slower than perturbation mode and introduces some noise into
the maps, however it does enable calculation of the density
modification Free-R. This is a weak indicator (in no way comparable to
the refinement free-R) which can be helpful in identifying the correct
enantiomorph, but is inadequate for choosing density modification
calculations.</DD>

<DT><A NAME="combine_nocomb"></A>NOCOMBINE</DT>

<DD> Disable phase combination. In cases where there are strong
density constraints (<EM>e.g.</EM> 4+ fold averaging) this may be useful to
avoid bias from the initial phases, especially if that phasing is from
an MR model.</DD>

<DT><A NAME="combine_restore"></A>RESTORE &lt;restorewt&gt;</DT>

<DD> &lt;restorewt&gt; is the weight which will be given to missing reflections
restored by density modification. The recommended value is 0.0-0.2 with
no averaging, up to 1.0 for high order averaging. The restored F's may
be accessed by assigning the FCDM output label. If a combined set of Fobs
and missing Fcalc is required, this should be generated by the user with
an appropriate weighting scheme. <BR>
</DD>
</DL>
(defaults: PERT, &lt;restorewt&gt;=0)

<H3><A NAME="scheme"></A>SCHEME ALL | AUTO | RES | MAG | FOM [[ FROM &lt;res&gt;
] [ FRAC &lt;frac&gt; ]]</H3>

<DL>
<DT><A NAME="scheme_all"></A>ALL</DT>

<DD> - Use all reflections for the whole calculation. Compulsory for
<A HREF="#ncycle_auto">NCYCLE AUTO</A>. (recommended for most non-averaging calculations).</DD>

<DT><A NAME="scheme_auto"></A>AUTO</DT>

<DD> - perform phase extension using a combination of resolution,
magnitude and FOM chosen on the basis of what the data set looks
like. This option will also pick a reasonable value for
&lt;frac&gt;. (alternative for non-averaging calculations).</DD>

<DT><A NAME="scheme_res"></A>RES</DT>

<DD> - perform phase extension in resolution steps, starting with the
low resolution data. (recommended for averaging calculations where a
great deal of phase extension must be performed). Note: any input
phase information beyond the initial resolution limit will be
incorporated as the calculation proceeds. </DD>

<DT><A NAME="scheme_mag"></A>MAG</DT>

<DD> - perform phase extension in magnitude steps, starting with the largest
reflections. </DD>

<DT><A NAME="scheme_fom"></A>FOM</DT>

<DD> - perform phase extension in FOM steps, starting with the best phased
data. </DD>

<DT><A NAME="scheme_frac"></A>FRAC &lt;frac&gt;</DT>

<DD> - fraction of the input data to use as a starting set. </DD>

<DT><A NAME="scheme_from"></A>FROM &lt;res&gt;</DT>

<DD> - sets &lt;frac&gt; to the fraction of the data within a resolution
sphere radius &lt;res&gt;. </DD>
</DL>
<P>(default: ALL, or AUTO for COMBINE FREE) </P>

<H3><A NAME="labin"></A>LABIN FP=.. SIGFP=.. [PHIO=.. FOMO=..] [HLA=..
HLB=.. HLC=.. HLD=..] [FDM=..] [PHIDM=..] [FOMDM=..] [FREE=..]</H3>

<P>Normally just the first four columns (FP,SIGFP,PHIO,FOMO) are input.
However if you have Hendrickson-Lattman coefficients you may want to input
these to the program as well (the difference is marginal except for SIR
data). If you want to start from the end of a previous density modification
calculation then the PHIDM, FOMDM columns are used. </P>

<DL>
<DT>FP</DT>

<DD> = F magnitude </DD>

<DT>SIGFP</DT>

<DD> = standard deviation, 0 for unmeasured </DD>

<DT>PHIO</DT>

<DD> = best initial phase estimate </DD>

<DT>FOMO</DT>

<DD> = weight attached to PHIO </DD>
</DL>

<DL>
<DT>HLA-HLD</DT>

<DD> = Hendrickson Lattman coefficients </DD>

<DT>FDM,PHIDM,FOMDM</DT>

<DD> = map coefficients of the starting map to which density modification
is to be applied, <EM>e.g.</A> from a previous density modification calculation
(phase and weight) or difference map coefficients from <A HREF="sigmaa.html">SIGMAA</A> (magnitude
and phase). FDM must be on the same scale as FP. </DD>

<DT>FREE</DT>

<DD> = free-R flag (only used if &lt;ncross&gt; &gt; 1) </DD>
</DL>

<H3><A NAME="labout"></A>LABOUT FDM=.. PHIDM=.. FOMDM=.. [FCDM=.. PHICDM=..] [HLADM=..
etc]</H3>

<P>Three columns are output by default, a magnitude, phase and
figure-of-merit. Normally a map would be calculated using FDM and
PHIDM (do not include the weight FOMDM). Alternatively a weighted map
with FP, PHIDM, FOMDM should give the same result, except that
restored magnitudes will be missing.</P>

<DL>
<DT>FDM</DT>

<DD>weighted (restored) structure factor for map calculation.</DD>

<DT>PHIDM</DT>

<DD>modified phase </DD>

<DT>FOMDM</DT>

<DD>weight attached to PHIDM </DD>

<DT>FCDM PHICDM</DT>

<DD>magnitude and phase from final modified map before phase recombination
</DD>

<DT>HLADM HLBDM HLCDM HLDDM</DT>

<DD>modified Hendrickson Lattman coefficients </DD>
</DL>

</table></div>

<H2><A NAME="keywords_advanced"></A><A NAME="keywords_averaging"></A>ADVANCED/AVERAGING KEYWORDS</H2>
<div align=center><table width=90% border=0><tr><td bgcolor=#a0a0ff><small>

<H3><A NAME="average"></A>AVERAGE [DOMAIN &lt;idom&gt;] [REFI [STEP &lt;dr&gt;
&lt;dphi&gt;] [EVERY &lt;nref&gt;]]</H3>

<P>Set a NCS symmetry averaging operator. This card is followed by rotation/translation
matrices on subsequent lines in either CCP4 or O/RAVE format. </P>

<DL>
<DT>CCP4 Formats (see also the program <A HREF="lsqkab.html">`lsqkab'</A>)</DT>

<DD> ROTA EULER &lt;alpha&gt; &lt;beta&gt; &lt;gamma&gt; (Euler angles)
<BR>
TRAN &lt;t1&gt; &lt;t2&gt; &lt;t3&gt; </DD>

<DT>or</DT>

<DD> ROTA POLAR &lt;omega&gt; &lt;phi&gt; &lt;kappa&gt; (Polar angles)
<BR>
TRAN &lt;t1&gt; &lt;t2&gt; &lt;t3&gt; </DD>

<DT>or</DT>

<DD> ROTA MATRIX &lt;r11&gt; &lt;r12&gt; &lt;r13&gt; &lt;r21&gt; &lt;r22&gt;
&lt;r23&gt; &lt;r31&gt; &lt;r32&gt; &lt;r33&gt; <BR>
TRAN &lt;t1&gt; &lt;t2&gt; &lt;t3&gt; </DD>

<DT>O/RAVE Format</DT>

<DD> OMAT <BR>
r11 r21 r31 <BR>
r12 r22 r32 <BR>
r13 r23 r33 <BR>
t1 t2 t3 <BR>
(note that the rotation matrix is transposed with respect to CCP4 matrix
format) </DD>

<DT>where</DT>

<DD> x' = r11 x + r12 y + r13 z + t1 <BR>
y' = r21 x + r22 y + r23 z + t2 <BR>
z' = r31 x + r32 y + r33 z + t3 </DD>
</DL>

<P>These are the operations which map the density in the region covered
by the input mask onto the other equivalent regions. The first operator
must be the identity matrix. The mask is input in CCP4 mask format on the
input file label NCSIN1. In the case of improper ncs, the mask must cover
just a monomer, for proper ncs it may cover the monomer or multimer. The
mask grid need not agree with the program grid. </P>

<P>If no input mask is assigned then 'dm' will attempt to generate one
automatically from the local density correlation, under the control of
the <A HREF="#ncsmask">NCSMASK</A> keyword. Always check the mask afterwards in an appropriate
graphics program (use the NCSOUT channel). </P>

<P><A NAME="average_domain"></A>If you want to apply different NCS operations
to different domains of the protein, give a set of AVER cards for each
DOMAIN, with the DOMAIN number on each AVER card (or the first for each
domain). An input mask is also required for each domain. The AVER DOMAIN
1 cards corresponds to the mask on NCSIN1, the AVER DOMAIN 2 to NCSIN2,
etc. The masks should be defined in the same multimer in the unit cell,
or at least in close proximity to one another. </P>

<P><A NAME="average_refi"></A><A NAME="average_step"></A><A NAME="average_every"></A>The
REF, STEP and EVERY cards will enable refinement of the NCS rotation matrices
between averaging cycles. The REF card enables the refinement of a particular
set of NCS parameters. Note that the STEP card allows different refinement
step sizes can be used for different domains, however all but one EVERY
card will be ignored. The refined matrices will be written out at the end
of the log file. </P>

<DL>
<DT>&lt;dr&gt;</DT>

<DD> = step size for refinement of positional parameters in Angstrom. </DD>

<DT>&lt;dphi&gt;</DT>

<DD> = step size for refinement of rotational parameters in degrees. </DD>

<DT>&lt;nref&gt;</DT>

<DD> = the number of phase extension cycles between each parameter refinement.
<BR>
(defaults &lt;dr&gt;=0.5 A, &lt;dphi&gt;=2.5 degrees, &lt;nref&gt;=3) See
also the document <A HREF="dm_ncs_averaging.html">dm_ncs_averaging</A>,
</DD>
</DL>

<H3><A NAME="ncsmask"></A>NCSMASK [OVERLAP] [INVERT] [NMER
&lt;nmer&gt;] [UPDATE &lt;cyc&gt;] [STEP &lt;step&gt;] [ALIM
&lt;u1&gt; &lt;u2&gt;] [BMIN &lt;v1&gt; &lt;v2&gt;] [CLIM &lt;w1&gt;
&lt;w2&gt;] [SIZE &lt;size&gt;] [BFAC &lt;bfac&gt;]</H3>

<P><A NAME="ncsmask_overlap"></A>Control ncs-matrix, masking, and auto-masking
behaviour. The OVERLAP card forces overlap removal for all NCS-masks. This
was the default mode of operation for old versions of `dm' which did not
support multimer masks; it must not be used if the NCS-mask covers a more
than one monomer. Note that the ncs-correlation statistics may be less
reliable when using a multimer mask. </P>

<P><A NAME="ncsmask_invert"></A>The INVERT card forces all symmetry operators
to be inverted (reversed), thus with this card the operator maps from the
symmetry related copy back onto the masked copy. </P>

<P>The NMER, STEP, ALIM, BLIM, CLIM, SIZE and BFAC cards control ncs-auto-masking
if no averaging mask is input. </P>

<DL>
<DT><A NAME="ncsmask_nmer"></A>NMER &lt;nmer&gt;</DT>

<DD> The number of monomers related by proper symmetries. This number is
automatically computed by the program, but the user has the option to
introduce his own choice, if needed. </P>

<P>For example: in the case
of 2-fold improper ncs the &lt;nmer&gt;=1. In the case of 2-fold proper
(<EM>i.e.</EM> rotational) ncs, &lt;nmer&gt;=2. In the case of a 2-fold ncs axis
perpendicular to a 3-fold crystallographic axis, 6 copies of the molecule
will obey the ncs operator, and so &lt;nmer&gt;=6.
Also, when the crystal contains a closed group of mixed crystallographic
and non-crystallographic symmetry (<EM>e.g.</EM> a 222 ncs with one ncs 2-fold and
one crystallographic 2-fold), the automatic determination of monomers might
go wrong. In such a case the user has to check the automatic assignment
to be sure the program is doing the correct thing. </DD>

<DT><A NAME="ncsmask_update"></A>UPDATE &lt;cyc&gt;</DT>

<DD> - Update the averaging mask every &lt;cyc&gt; cycles. This allows
an input mask to be refined after the first few cycles, or for an
automask to be refined.</DD>

<DT><A NAME="ncsmask_step"></A>STEP &lt;step&gt;</DT>

<DD> The coarseness of the search to find the ncs averaging mask. Increasing
this value will speed up the mask calculation, decreasing it will produce
a better mask. Values of 2,3, or 4 are realistic. </DD>

<DT><A NAME="ncsmask_alim"></A>ALIM &lt;u1&gt; &lt;u2&gt;</DT>

<DD> Limits on the search space over which the mask is to be formed. These
are necessary if an ncs-axis lies perpendicular to a cell edge, thus the
ncs maps the cell repeat to itself along that axis. In this case the mask
must be limited to a single repeat along that direction, <EM>e.g.</EM> ALIM 0 1
or ALIM -0.5 0.5 sets limits along a-axis. </DD>

<DT><A NAME="ncsmask_blim"></A>BLIM &lt;v1&gt; &lt;v2&gt;</DT>

<DD> See ALIM. Sets limits along B axis. </DD>

<DT><A NAME="ncsmask_clim"></A>CLIM &lt;w1&gt; &lt;w2&gt;</DT>

<DD> See CLIM. Sets limits along B axis. </DD>

<DT><A NAME="ncsmask_size"></A>SIZE &lt;size&gt; (usually not needed)</DT>

<DD> If the ncsautomask procedure gives an out-of-memory error place a
number greater than 1 on this card. </DD>

<DT><A NAME="ncsmask_bfac"></A>BFAC &lt;bfac&gt; (usually not needed)</DT>

<DD> Temperature factor for smoothing the map before calculating local
correlation. </DD>
</DL>

<P>Defaults: &lt;nmer&gt;=1, &lt;step&gt;=3, &lt;size&gt;=1, &lt;bfac&gt;=20.
</P>

<H3><A NAME="solmask"></A> SOLMASK [ UPDATE &lt;cyc&gt; ] [ FRAC &lt;solvfrac&gt; &lt;protfrac&gt; ] [ RADIUS &lt;radius&gt; &lt;mode&gt; ] [ LIMITS &lt;rhomin&gt; &lt;rhomax&gt; ]</H3>

<P>Set parameters for calculation of the solvent mask.
</P>

<DL>
<DT><A NAME="solmask_update"></A>UPDATE &lt;cyc&gt;</DT>

<DD> - Update the solvent mask every &lt;cyc&gt; cycles. This allows
an input mask to be refined after the first few cycles. </DD>

<DT><A NAME="solmask_frac"></A>FRAC &lt;solvfrac&gt; &lt;protfrac&gt;</DT>

<DD> - used to set different mask volumes to the above for histogram matching
and solvent flattening. <BR>
&lt;solvfrac&gt; = fraction of cell to be masked as solvent. <BR>
&lt;protfrac&gt; = fraction of cell to be masked as protein. <BR>

If &lt;solvfrac&gt;+&lt;protfrac&gt; &lt; 1.0 then there will be a
buffer region between solvent and protein which is neither histogram
matched or solvent flattened. This feature allows uncertain regions to
be neither solvent flattened nor histogram matched.</DD>

<DT><A NAME="solmask_radius"></A>RADIUS &lt;radius&gt; &lt;mode&gt;</DT>

<DD> &lt;radius&gt; = radius of averaging sphere (Angstroms) <br>
&lt;mode&gt; = 0: Use weighting scheme w=constant (Spherical top hat) <br>
&lt;mode&gt; = 1: Use weighting scheme w=1-(r/R) (Wang's method) <br>
&lt;mode&gt; = 2: Use weighting scheme w=1-(r/R)**2 <br>
</DD>
</DL>

<P>Heavy atoms can bias the mask calculation procedure, resulting in a
mask of spheres around the heavy atom sites. The LIMITS card can be used
to set the values at which the electron density is truncated before smoothing.
To truncate heavy atoms set &lt;rhomax&gt; to the maximum electron density
due to non-heavy atoms at the appropriate resolution. </P>

<P>If a negative Wang radius is given, then the program will determine
a suitable radius from the data. This radius will decrease as the calculation
progresses. <BR>
(defaults &lt;radius&gt;=-1.0 &lt;mode&gt;=2 &lt;rhomin&gt;=0.32 &lt;rhomax&gt;=2.0
e/A^3) </P>

</table></div>

<H2><A NAME="keywords_other"></A>OTHER KEYWORDS</H2> Don't use these
unless you really know what you are doing. In which case you'd better
have a better idea of what you are doing than I do.
<div align=center><table width=90% border=0><tr><td bgcolor=#ff8080><small>

<H3><A NAME="combine_full"></A>COMBINE  RPERT | EMPIRICAL | GAMMA &lt;gamma&gt; | FREE &lt;ncross&gt; [ SETS &lt;numsets&gt; ] [ WEIGHT &lt;cmbwt&gt; ]</H3>

<DL>
<DT><A NAME="combine_rpert"></A>RPERT</DT>

<DD> Use resolution dependent perturbation gamma correction for bias
reduction. This is generally unnecessary with current density
modifications. <A HREF="#combine_pert">COMBINE PERT</A> already incorporates the necessary
resolution dependence for <A HREF="#mode_mult">MODE MULTI</A>.</DD>

<DT><A NAME="combine_empi"></A>EMPIRICAL</DT>

<DD> Use empirical gamma correction (<A HREF="#reference12">reference [12]</A>)</DD>

<DT><A NAME="combine_gamma"></A>GAMMA &lt;gamma&gt;</DT>

<DD> Use a gamma correction of &lt;gamma&gt;</DD>

<DT><A NAME="combine_free"></A>FREE &lt;ncross&gt;</DT>

<DD> Use Free-Sim phase combination. &lt;ncross&gt; = number of times each
step is performed to provide statistics for the free-R and phase weighting.
</DD>

<DD>For &lt;ncross&gt;=1 a changing random set of reflections are omitted
each cycle for the free-R factor. </DD>

<DD>For &lt;ncross&gt;=2 a fixed set is chosen (using the free-R flag if
available) and omitted for the free-R factor, then the cycle is run a second
time using all the reflections. </DD>

<DD>For &lt;ncross&gt; &gt; 2 (&lt;ncross&gt;-1) multiple free-R sets are
generated, then on the &lt;ncross&gt;-th cycle all reflections are included.
<BR>
The total time taken is proportional to the product of these two values.
Use &lt;ncross&gt; = 1 for large structures where the time becomes a significant
factor, otherwise use &lt;ncross&gt; = 2. Only use &lt;ncross&gt; &gt;
2 for small structures where the statistics are particularly poor (&lt;
5000 reflections). </DD>

<DT><A NAME="combine_sets"></A>SETS &lt;numsets&gt;</DT>

<DD> &lt;numsets&gt; is the number of free sets into which the data will
be divided. These are used both in Free-Sim and Reflection Omit modes.
In reflection omit mode the calculation time increases in proportion to
the number of free sets. </DD>

<DT><A NAME="combine_weight"></A>WEIGHT &lt;cmbwt&gt;</DT>

<DD> &lt;cmbwt&gt; is a weight applied to the initial phasing in phase
combination. Normally &lt;cmbwt&gt;=1, COMBINE NOCOMBINE implies
&lt;cmbwt&gt;=0</DD>

</DL>
(&lt;ncross&gt;=1, &lt;numsets&gt;=20)

<H3><A NAME="resolution"></A>RESOLUTION &lt;rmin&gt; &lt;rmax&gt; </H3>

<P>Resolution range of reflections to include in the calculation. This
keyword can be used to exclude part of the input data by resolution
cutoffs. This is generally highly inadvisable.<BR> (default is the
whole range of the input mtz file) </P>

<H3><A NAME="skel"></A>SKEL [ LENGTH &lt;joinlen&gt; &lt;endlen&gt; ] [
BFAC &lt;bfac&gt; ] [ EVERY &lt;nskl&gt; ]</H3>

<P>Perform iterative skeletonisation on the map. Cycles of skeletonisation
are interspersed with cycles of conventional density modification. </P>

<DL>
<DT><A NAME="skel_joinlen"></A>&lt;joinlen&gt;</DT>

<DD> = length of skeleton in Angstrom/residue to generate between density
peaks. </DD>

<DT><A NAME="skel_endlen"></A>&lt;endlen&gt;</DT>

<DD> = length of skeleton in Angstrom/residue to generate in `trailing
ends'. </DD>

<DT><A NAME="skel_bfac"></A>&lt;bfac&gt;</DT>

<DD> = temperature factor to apply to the sharpened map before skeletonisation.
</DD>

<DT><A NAME="skel_nskl"></A>&lt;nskl&gt;</DT>

<DD> = apply skeletonisation instead of every &lt;nskl&gt;-th density modification
cycle. <BR>
(defaults &lt;joinlen&gt;=6.0 &lt;endlen&gt;=6.0 &lt;bfac&gt;=45 &lt;nskl&gt;=3)
<BR>
See also the document <A HREF="dm_skeletonisation.html">`dm_skeletonisation'</A>. </DD>
</DL>

<H3><A NAME="grid"></A>GRID &lt;nx&gt; &lt;ny&gt; &lt;nz&gt;</H3>

<P>Set the grid for the calculation. You may want to do this if you want
to output a map or mask. <BR>
(defaults: minimum efficient factors above Nyquist spacing) </P>

<H3><A NAME="scale"></A>SCALE &lt;scale&gt; &lt;bfac&gt;</H3>

<P>Override internal scaling and scale input data by F^2 = &lt;scale&gt;
* exp (&lt;bfac&gt; * s / 2.0) * F^2. Scaling is critical to histogram
mapping and Sayre's equation. In some cases you may want to override the
B-factor, but run without this card first, and consider long and hard before
changing scale. </P>

<H3><A NAME="realfree"></A>REALFREE [SOLV &lt;sx&gt; &lt;sy&gt;
&lt;sz&gt; &lt;sr&gt;] [PROT &lt;px&gt; &lt;py&gt; &lt;pz&gt;
&lt;pr&gt;]</H3>

<P>Enable the real-free residual (implied by <A HREF="#ncycle_auto">NCYCLE AUTO</A>). Optionally
set the coordinates and radii (in Angstrom) of the spherical patches
of density where the density modification constraints will be omitted
in order to provide a real-space free indicator of progress. If
&lt;sr&gt; or &lt;pr&gt; is negative the Solvent or Protein free
indicator will be omitted. <BR> (defaults: &lt;sr&gt;=4.0
&lt;pr&gt;=4.0, coordinates chosen from solvent mask). </P>

</small></table></div>

<H2><A NAME="harvesting"></A>DATA HARVESTING KEYWORDS</H2>
<div align=center><table width=90% border=0><tr><td bgcolor=#a0a0ff><small>

<p>Provided a Project Name and a Dataset Name are specified (either explicitly
or from the MTZ file) and provided the <a href="#general_noharvest">NOHARVEST</a>
keyword is not given, the program will automatically produce a data harvesting
file. This file will be written to</p>

<p><tt>$HARVESTHOME</tt>/<tt>DepositFiles</tt>/<i>&lt;projectname&gt;</i>/
<i>&lt;datasetname&gt;.dm</i></p>

<p>The environment variable <tt>$HARVESTHOME</tt> defaults to the user's
home directory, but could be changed, for example, to a group project
directory. When running the program through the CCP4 interface, the $HARVESTHOME variable defaults to the 'PROJECT' directory.</p>

<h3><a name="general_pname">PNAME</a>&lt;project_name&gt;</h3>

<p>Project Name. In most cases, this will be inherited from the MTZ file.</p>

<h3><a name="general_dname">DNAME</a>&lt;dataset_name&gt;</h3>

<p>Dataset Name. In most cases, this will be inherited from the MTZ file.</p>

<h3><a name="general_private">PRIVATE</a></h3>

<p>Set the directory permissions to '700', <em>i.e.</em> read/write/execute for
the user only (default '755').</p>

<h3><a name="general_usecwd">USECWD</a></h3>

<p>Write the deposit file to the current directory, rather than a
subdirectory of $HARVESTHOME. This can
be used to send deposit files from speculative runs to the local directory
rather than the official project directory, or can be used 
when the program is being run on a machine without access to the directory
<tt>$HARVESTHOME</tt>.</p>

<h3><a name="general_rsize">RSIZE</a>&lt;row_length&gt;</h3>

<p>Maximum width of a row in the deposit file (default 80).
&lt;row_length&gt; should be between 80 and 132 characters.</p>

<h3><a name="general_noharvest">NOHARVEST</a></h3>

<p>Do not write out a deposit file; default is to do so provided Project
and Dataset names are available.</p>
</table></div>

<H2><A NAME="looking_at_your_output"></A>LOOKING AT YOUR OUTPUT</H2>

<P>Two free indicators may be generated. The density modification
Free-R is calculated in <A HREF="#combine_omit">COMBINE OMIT</A> mode. This is a weak indicator
(in no way comparable to the refinement free-R) which can be helpful
in identifying the correct enantiomorph, but is inadequate for choosing
density modification calculations.</P>

<P>The <A HREF="#ncycle_auto">NCYCLE AUTO</A> or <A HREF="#realfree">REALFREE</A> keywords enable calculation of the
real-space free residual, which provide some information when used in
conjunction with <A HREF="#scheme_all">SCHEME ALL</A>.</P>

<P>The LogGraph output, as well as showing the free-R factor, gives some
information on the quality and completeness of the input data, and also
a plot of the data fit against a standard protein data set. </P>

<P>For NCS-averaging calculations, correlations are calculated between
related areas of density. These are summarised at the end of the log file,
and error or warning messages will be generated if the initial values are
too low: this is a good indication of errors in the input matrices or mask.
</P>

<P>Also check the statistics of the averaging mask. If using a monomer
mask, the masked fraction or the cell multiplied by the number of monomers/ASU
multiplied by the order of crystallographic symmetry should give the protein
faction. In the case of a multimer mask, this is reduced by the size of
the multimer. </P>

<H2>AUTHOR</H2>

<P>Kevin D. Cowtan, Department of Chemistry, University of York <BR>
email: cowtan@ysbl.york.ac.uk </P>

<H2><A NAME="references"></A>REFERENCES</H2>

<OL>
<P><!-- KEEP startreferencelist --></P>

<LI><A NAME="reference1"></A>Baker D., Bystroff C., Fletterick R., Agard D. (1994) Acta Cryst D49
429-439 </LI>

<LI><A NAME="reference2"></A>Bricogne, G. (1974) Acta Cryst A30 395-405 </LI>

<LI><A NAME="reference3"></A>Brunger, A. T. (1992) Nature 355, 472-474. </LI>

<LI><A NAME="reference4"></A>Cowtan K. D., Main, P. (1993) Acta Cryst D49 148-157 </LI>

<LI><A NAME="reference5"></A>Sayre, D. (1974) Acta Cryst A30 180-184 </LI>

<LI><A NAME="reference6"></A>Schuller D. (1996) Acta Cryst D52 425-434 </LI>

<LI><A NAME="reference7"></A>Swanson, S. (1994) Acta Cryst D50 695-708 </LI>

<LI><A NAME="reference8"></A>Wang, B. C. (1985) Methods in Enzymology 115, 90-112 </LI>

<LI><A NAME="reference9"></A>Zhang, K. Y. J., Main P. (1990) Acta Cryst A46 377-381 </LI>

<LI><A NAME="reference10"></A>Abrahams, J. P. (1995) Acta Cryst D51 371-376 </LI>

<LI><A NAME="reference11"></A>K. D. Cowtan, P. Main (1996) Acta Cryst D52 43-48 </LI>

<LI><A NAME="reference12"></A>K. D. Cowtan (1999) Acta Cryst D55 1555-1567 </LI>
<!-- KEEP endreferencelist -->
</OL>

<H2>SEE ALSO</H2>

<P><A HREF="cad.html">cad</A>, <A HREF="lsqkab.html">lsqkab</A>, <A HREF="xloggraph.html">xloggraph</A>,
<A HREF="dm_skeletonisation.html">dm_skeletonisation</A>, <A HREF="dm_ncs_averaging.html">dm_ncs_averaging</A>
</P>

<H2><A NAME="examples"></A>EXAMPLES</H2>

<P><A HREF="../examples/unix/runnable/dm.exam">dm</A> </P>

<PRE>#
#[ a simple solvent/histogram calculation          ]
#

dm      hklin gmto.mtz  hklout gmtodm.mtz  &lt;&lt; my-data
SOLC 0.35
MODE SOLV HIST
COMBINE PERT
NCYCLE 10
LABIN FP=FP SIGFP=SIGFP PHIO=PHIB FOMO=FOM
LABOUT PHIDM=PHI1 FOMDM=W1
my-data

#
#[ a better solvent/histogram/multires calculation,]
#[ uses NCYCLE AUTO to terminate before phase bias ]
#[ sets in, bias reduction using perturbation-gamma]
#

dm      hklin gmto.mtz  hklout gmtodm.mtz  &lt;&lt; my-data
SOLC 0.35
MODE SOLV HIST MULT
COMBINE PERT
NCYCLE AUTO
SCHEME ALL
LABIN FP=FP SIGFP=SIGFP PHIO=PHIB FOMO=FOM HLA=HLA HLB=HLB HLC=HLC HLD=HLD
LABOUT PHIDM=PHI1 FOMDM=W1
my-data

#
#[ a molecular replacement type calculation]
#[ sigmaa is used to generate FOMs for the ]
#[ Fcalc, PHIcalc                          ]
#

sigmaa hklin gmto_sfall.mtz   hklout gmto_sigmaa.mtz &lt;&lt; eof
partial
labin FP=FP SIGFP=SIGFP FC=FCmolr PHIC=PHICmolr
eof

dm     hklin gmto_sigmaa.mtz  hklout gmtodm.mtz  &lt;&lt; my-data
SOLC 0.35
MODE SOLV HIST
COMBINE PERT
NCYCLE 10
LABIN FP=FP SIGFP=SIGFP PHIO=PHICmolr FOMO=WCMB
my-data

#
# NON-CRYSTALLOGRAPHIC SYMMETRY AVERAGING
#[ A three fold averaging calculation      ]
#[ This could also be done in reflection   ]
#[ omit mode if you have enough time       ]
#

dm   hklin chmimir.mtz hklout dmchm.mtz   
     ncsin1 chmi.msk                      
     &lt;&lt; MY-DATA
SOLC 0.52
NCYC 10
MODE SOLV HIST AVER
COMBINE PERT
AVER REFI
ROTA POLAR  0.0  0.0  0.0
TRANS  0.0  0.0  0.0
AVER REFI
ROTA POLAR  113.28130 103.41944 120.33858
TRANS  43.635 38.059 62.726
AVER REFI
ROTA POLAR   66.58067 -76.78019 119.69176
TRANS  82.989 15.401 -8.928
LABI FP=F SIGFP=SIGF PHIO=PHIB FOMO=FOM HLA=HLA HLB=HLB HLC=HLC HLD=HLD
LABO PHIDM=PHIDM FOMDM=FOMDM
END
MY-DATA

#
# NON-CRYSTALLOGRAPHIC SYMMETRY AVERAGING
#[ A three fold averaging calculation with ]
#[ extreme phase extension <EM>e.g.</EM> 8.0 - 3.0&#197; ]
#[ must be done more carefully, hence      ]
#[ NCYC and SCHEME cards                   ]
#

dm   hklin chmimir.mtz hklout dmchm.mtz   
     ncsin1 chmi.msk                      
     &lt;&lt; MY-DATA
SOLC 0.52
MODE SOLV HIST AVER
COMBINE PERT
SCHEME RES FROM 8.0
NCYC 1000
AVER REFI
ROTA POLAR  0.0  0.0  0.0
TRANS  0.0  0.0  0.0
AVER REFI
ROTA POLAR  113.28130 103.41944 120.33858
TRANS  43.635 38.059 62.726
AVER REFI
ROTA POLAR   66.58067 -76.78019 119.69176
TRANS  82.989 15.401 -8.928
LABI FP=F SIGFP=SIGF PHIO=PHIB FOMO=FOM
LABO PHIDM=PHIDM FOMDM=FOMDM
END
MY-DATA

#
# NON-CRYSTALLOGRAPHIC SYMMETRY AVERAGING WITH AUTOMASK
#[ A 3-fold averaging calculation. No input averaging ]
#[ mask is required, the the NCSMASK NMER keyword is  ]
#[ added. Mask is updated occasionally.               ]
#

dm   hklin chmimir.mtz hklout dmchm.mtz   
     &lt;&lt; MY-DATA
SOLC 0.52
NCSMASK NMER 3 UPDATE 4
NCYC 10
MODE SOLV HIST AVER
COMBINE PERT
AVER REFI
ROTA POLAR  0.0  0.0  0.0
TRANS  0.0  0.0  0.0
AVER REFI
ROTA POLAR  113.28130 103.41944 120.33858
TRANS  43.635 38.059 62.726
AVER REFI
ROTA POLAR   66.58067 -76.78019 119.69176
TRANS  82.989 15.401 -8.928
LABI FP=F SIGFP=SIGF PHIO=PHIB FOMO=FOM
LABO PHIDM=PHIDM FOMDM=FOMDM
END
MY-DATA

#
# MULTI-DOMAIN AVERAGING
#[ a two fold averaging calculation with   ]
#[ two domains and refinement of the 2nd   ]
#[ set of averaging matrices.              ]
#[ WARNING: IF YOU DONT KNOW WHAT MULTI-   ]
#[ DOMAIN AVERAGING IS, YOU DONT NEED IT   ]
#

dm  hklin hpattj.mtz    hklout dm1.mtz       
    ncsin1 cwnads.mask  ncsin2 cwglobs.mask 
    &lt;&lt; EOF-dm
SOLC 0.57
MODE SOLV HIST AVER
NCYCLE 40
AVERAGE DOMAIN 1
OMAT
 1.0 0.0 0.0
 0.0 1.0 0.0
 0.0 0.0 1.0
 0.0 0.0 0.0
AVERAGE DOMAIN 1
OMAT
    -0.71389002    -0.69492584     0.08611962
    -0.69635397     0.69129372    -0.19136506
     0.07357326    -0.19652288    -0.97735721
   115.37364197    54.98566055    67.00005341
AVERAGE DOMAIN 2 REFINE
ROTA MATRIX  1.0 0.0 0.0 -
             0.0 1.0 0.0 -
             0.0 0.0 1.0
TRANS 0.0 0.0 0.0
AVERAGE DOMAIN 2 REFINE
ROTA MATRIX     0.75830859     0.65183645     0.00883542  -
                0.65189570    -0.75824565    -0.00975925  -
                0.00033828     0.01316060    -0.99991322
TRANS    17.30371666   -47.10081482    68.99727631
LABIN FP=FP SIGFP=SIGFP PHIO=PHIml FOMO=FOMml HLA=HLA HLB=HLB HLC=HLC HLD=HLD
LABOUT PHIDM=PHIDM FOMDM=FOMDM
EOF-dm

#
# NOTE: If you don't know what multi-domain averaging is,
# you don't need it. Use the ncs averaging example, not
# the multi-domain example.
#

</PRE>

</BODY>
</HTML>
