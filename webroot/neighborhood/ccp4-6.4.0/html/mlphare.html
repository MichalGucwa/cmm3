<!doctype html public "-//w3c//dtd html 3.2//en">
<html>
<head>
   <title>CCP4 Program Suite : mlphare</title>
   <meta name="GENERATOR" content="Mozilla/3.0Gold (X11; I; IRIX 6.2 IP22) [Netscape]" />
</head>
<body>

<!-- ::INDEX_INFO::MLPHARE::Supported::Multiple Isomorphous Replacement,MULTIWAVELENGTH ANOMALOUS DISPERSION::maximum likelihood heavy atom refinement and phase calculation:::::::: -->

<h1>MLPHARE (CCP4: Supported Program)</h1>
<h2>NAME</h2>
<p><b>mlphare</b>
- maximum likelihood heavy atom refinement and phase calculation</p>

<h2>SYNOPSIS</h2>

<p><b>mlphare hklin</b> <i>foo.mtz</i> <b>hklout</b> <i>foo_out.mtz</i>
<b>newparm</b> <i>foo_out.com</i> [<b>xyzout</b> <i>foo.brk</i>]<br />
[<a href="#keywords">Keyworded input</a>]</p>

<h2><a name="description"></a>DESCRIPTION</h2>

<p>This program will refine heavy atom parameters and error estimates, then
use these refined parameters to generate phase information. The maximum
number of heavy atoms which may be refined is 130 over a maximum of 20 derivatives.
The program was originally written for MIR, but may also be used for phasing
from MAD data, where the different wavelengths are interpreted as different
&quot;derivatives&quot;.</p>

<p>Beware: This program is fundamentally different from the old PHARE, even
though some of the code looks familiar. The incorporation of the concepts
of Maximum Likelihood means that the refinement of parameters is much more
robust, and the generation of phases and figures of merit is more realistic.
See <a href="#notes_on_usage">NOTES ON USAGE</a>.</p>

<p>Note: heavy atom parameters can also be refined in vector-space using
the program <a href="vecref.html">VECREF</a>.</p>

<p><a name="references"></a>Ref: Z.Otwinowski: Daresbury Study Weekend proceedings, 1991</p>

<h2><a name="keywords"></a>KEYWORDED INPUT</h2>

<p>Keywords are divided into two sets.</p>

<h4><a name="keywords_general"></a>Set 1: general keywords</h4>

<p>These keywords control the calculation. Compulsory keywords are:</p>

<pre>
      <a href="#general_labin"><b>LABIN</b></a>
      <a href="#general_cycle"><b>CYCLE</b></a> or <a href="#general_phase"><b>PHASE</b></a>
      <a href="#general_labout"><b>LABOUT</b></a> - essential if you wish to output an HKLOUT file.
      <a href="#general_end"><b>END</b></a> - to designate the end of input; if more than one
            derivative is described, the keyword <a href="#derivative_deriv">DERIV</a>
            designates the end of input for the previous derivative.
</pre>

<p>Optional keywords are:
<blockquote>
<a href="#general_angle"><b>ANGLE</b></a>, <a href="#general_apply"><b>APPLY</b></a>,
<a href="#general_centric"><b>CENTRIC</b></a>, <a href="#general_coords"><b>COORDS</b></a>,
<a href="#general_exclude"><b>EXCLUDE</b></a>, <a href="#general_skip"><b>SKIP</b></a>,
<a href="#general_fhout"><b>FHOUT</b></a>,
<a href="#general_hlout"><b>HLOUT</b></a>, <a href="#general_print"><b>PRINT</b></a>,
<a href="#general_resolution"><b>RESOLUTION</b></a>, <a href="#general_scale"><b>SCALE</b></a>,
<a href="#general_script"><b>SCRIPT</b></a>, <a href="#general_threshold"><b>THRESHOLD</b></a>,
<a href="#general_title"><b>TITLE</b></a>
</blockquote>

<p>In addition, the following optional keywords control the data harvesting
functionality:
<blockquote>
<a href="#general_pname"><b>PNAME</b></a>, <a href="#general_dname"><b>DNAME</b></a>,
<a href="#general_private"><b>PRIVATE</b></a>, <a href="#general_usecwd"><b>USECWD</b></a>,
<a href="#general_rsize"><b>RSIZE</b></a>, <a href="#general_noharvest"><b>NOHARVEST</b></a>
</blockquote>

<h4><a name="keywords_derivative"></a>Set 2: derivative keywords which MUST follow the above list</h4>

<p>These are repeated once for each derivative.</p>

<p>Compulsory keywords are:
<blockquote>
<a href="#derivative_atom"><b>ATOM</b></a>, <a href="#derivative_atref"><b>ATREF</b></a>,
<a href="#derivative_dcycle"><b>DCYCLE</b></a>, <a href="#derivative_deriv"><b>DERIVATIVE</b></a>
</blockquote>

<p>Optional keywords are:
<blockquote>
<a href="#derivative_anoerror"><b>ANOERROR</b></a>, <a href="#derivative_exclude"><b>EXCLUDE</b></a>,
<a href="#derivative_isoerror"><b>ISOERROR</b></a>, <a href="#derivative_resolution"><b>RESOLUTION</b></a>,
<a href="#derivative_scale_fph"><b>SCALE</b></a>, <a href="#derivative_wave"><b>WAVE</b></a>
</blockquote>

<h3>Set 1: general keywords</h3>

<a name="keywords_general_compulsory"></a>
<h3><a name="general_cycle"></a>CYCLE &lt;ncycle&gt; [ &lt;kcycle1&gt; &lt;kcycle2&gt;
.....]</h3>

<p>&lt;ncycle&gt; sets the number of cycles that the program will run (default
10). The first (&lt;ncycle&gt;-1) cycles are used for refinement of the
heavy atom parameters and the error estimates. The phases for ALL reflections
in the file to the outer resolution limit are calculated on the final cycle.
Statistics may be collected for both the final cycle of refinement, and the
phasing cycle.</p>

<p>&lt;kcycle1&gt; &lt;kcycle2&gt; ... are flags for externally calculated
phases and need only be set if you want to use these. In general the refinement
procedure works out the likely weighting of all possible protein phases
sampled round the phase circle and uses this information to do a phased
refinement. Any particular derivative contribution will be controlled by
the parameters on the <a href="#derivative_dcycle">DCYCLE</a> input line.</p>

<p>If you want to input phases calculated elsewhere and use them in refinement
for some cycles, list these cycle numbers here. <em>E.g.</em>:<br />
CYCLE 10 2 3 5 7 9<br />
would mean that 10 cycles will be run, 9 for refinement and a final phasing
cycle, and that external phases would be used during refinement on cycles
2, 3, 5, 7 and 9. If these flags are set you must assign a column for PHIC,
and for either WC or FC. See <a href="#notes_on_phic">NOTES ON PHIC</a> for details of how these are
used. A contribution may be added to the phase likelihood calculated from
derivatives to favour the external phase or it may be used alone.</p>

<h3><a name="general_phase"></a>PHASE</h3>

<p>This keyword signals that you ONLY want to calculate phases and not
to do any refinement. It is equivalent to CYCLE 1. The phases for ALL reflections
in the file to the outer resolution limit are calculated.</p>

<h3><a name="general_labin"></a>LABIN &lt;program label&gt;=&lt;file label&gt;
.....</h3>

<p>Associates the column labels that the program expects with column labels
in the input file. The following &lt;program label&gt;s can be assigned:</p>

<pre>
        FP      SIGFP      
        FPH1    SIGFPH1    DPH1    SIGDPH1  
        FPH2    SIGFPH2    DPH2    SIGDPH2  
        FPH3    SIGFPH3    DPH3    SIGDPH3  
        FPH4    SIGFPH4    DPH4    SIGDPH4  
        FPH5    SIGFPH5    DPH5    SIGDPH5  
        .
        .
        .
        FPH20   SIGFPH20   DPH20   SIGDPH20 
        FC      PHIC      WC   
        F0      F1        F2       F3   ..F19
</pre>

<p>Where:</p>

<dl>
<dt>H, K, L</dt>

<dd></dd>

<dt>FP</dt>

<dd>Native F</dd>

<dt>SIGFP</dt>

<dd>sigma(FP)</dd>
</dl>

<p>Then for each derivative (i=derivative number)</p>

<dl>
<dt>FPHi</dt>

<dd>Derivative F</dd>

<dt>SIGFPHi</dt>

<dd>sigma(FPHi)</dd>

<dt>[DPHi]</dt>

<dd>Anomalous difference (if anomalous data are used)</dd>

<dt>[SIGDPHi]</dt>

<dd>sigma(DELi)</dd>
</dl>

<p>For externally calculated phases</p>

<dl>
<dt>PHIC</dt>

<dd>The phases to be used in refinement. This is only needed if the &lt;kcycle&gt;
flags have been set. See keyword <a href="#general_cycle">CYCLE</a>.</dd>

<dt>[WC]</dt>

<dd>Weight for these phases. Defaults to 1.0.</dd>

<dt>[FC]</dt>

<dd>Fcalc value. Used to estimate Sim Weight for calculated phases.</dd>
</dl>

<p>F0 F1 .. Assignments for selected extra columns to be copied to the
output file. <i>NB</i> F0, F1 etc should not be assigned if
<a href="#general_labout">LABOUT ALLIN</a> is also being used.</p>

<p>Assignments are required for FP, SIGFP, and at least one derivative
(FPH1, SIGFPH1). The number of derivatives is deduced from the FPHi assignments.</p>

<p>If you wish to copy all columns from input to output file, specify ALLIN
on the LABOUT line. If you wish to copy selected columns from input to
output file, you may assign up to 19 columns, using F0 F1 ... F19</p>

<h3><a name="general_labout"></a>LABOUT [ ALLIN | [ &lt;program label&gt;=&lt;file
label&gt; ... ] ]</h3>

<p>Associates column labels in the output file with labels used by the
program.</p>

<p>Specifying ALLIN copies all input columns to output. <i>NB</i> if ALLIN is
specified then <a href="#general_labin">LABIN F0=... F1=...</a> etc should
not be used.</p>

<p>The following extra labels can be assigned.</p>

<pre>        PHIB    FOM
        HLA     HLB        HLC     HLD
        FH1     PHIH1      FHA1    PHIHA1
        FH2     PHIH2      FHA2    PHIHA2
        .....
        FH20    PHIH20     FHA20   PHIHA20
</pre>

<p>where</p>

<dl>
<dt>PHIB</dt>

<dd>maximum likelihood phase</dd>

<dt>FOM</dt>

<dd>figure of merit</dd>

<dt>HLA,HLB,HLC,HLD</dt>

<dd>Hendrickson-Lattman coefficients output if HLOUT requested</dd>

<dt>FHi PHIHi FHAi PHIHAi</dt>

<dd>give the heavy atom real and imaginary structure factors. Output if
FHOUT is requested for this derivative (the FPHi SIGFPHi [ DPHi SIGDPHi
] will also be copied to the output file). This information is needed if
you want to do double difference Fourier to find more heavy atom sites.
See the <a href="fft.html#map_ddiff">FFT documentation</a>.</dd>

<dt>FP SIGFP PHIB and FOM</dt>

<dd>are always output.</dd>
</dl>

<p>The following are copied from the input file if they have been assigned.</p>

<pre>        FC      PHIC      WC
        F0      F1        F2       F3   ..F11
</pre>

<p>If LABOUT is specified the program outputs a file assigned to HKLOUT
containing at least H K L FP SIGFP PHIB FOM and other optional columns
FOR ALL REFLECTIONS to the outer resolution cut off. IF LABOUT is NOT specified
you get no output file.</p>

<p>For certain problems it is convenient to assign FP and FPHi to the same
column.</p>

<h3><a name="keywords_general_optional"></a>Optional keywords:</h3>

<h3><a name="general_angle"></a>ANGLE &lt;iangle&gt;</h3>

<p>&lt;iangle&gt; is the angle interval in degrees for calculation of the
phase probability curve (default 10).</p>

<p><em>N.B.</em>: The program speed is proportional to 360/&lt;iangle&gt;. ZO recommends
&lt;iangle&gt;=20 except when the derivative has high phasing power, then
&lt;iangle&gt;=10. EJD always uses &lt;iangle&gt;=10 - time is not so valuable...</p>

<h3><a name="general_apply"></a>APPLY</h3>

<p>The final overall scale and B values for each derivative are applied
to FPHi, SIGFPHi, DPHi, SIGDPHi before these are written to HKLOUT. The
default is to simply echo the columns which are input.</p>

<h3><a name="general_centric"></a>CENTRIC</h3>

<p>This restricts the program to use only centric reflections for refinement.
This is sensible if you have enough centric data. In general there are
many many more observations than heavy atom parameters to refine, and the
coordinates and relative real occupancies can often be accurately refined
from the centric data alone. You will however have to use acentric data to refine
the anomalous occupancy. In that case, it is sensible to refine the coordinates
and real occupancies against centric data first, and include acentric data
in a second run.</p>

<h3><a name="general_skip"></a>SKIP &lt;nskip&gt;</h3>

<p>&lt;nskip&gt; The program only uses every "Icycle+nskip-th" reflection for refinement.
This saves a great deal of time. The reflection set changes with each cycle. The final 
phasing cycle uses all reflections. </p>

<h3><a name="general_exclude"><a name="general_exclude_sigfp"></a>EXCLUDE [SIGFP &lt;siglim&gt;]</h3>

<p>If SIGFP is followed by a number &lt;siglim&gt; reflections are excluded
if FP &lt; siglim*SIGFP. Other <a href="#derivative_exclude">EXCLUSION</a> tests are given for each derivative
in turn.</p>

<h3><a name="general_fhout"></a>FHOUT [DERIV] &lt;i1&gt; &lt;i2&gt; ...</h3>

<p>&lt;i1&gt; &lt;i2&gt;... give the derivative numbers for which you want
FHi PHIHi [FHAi PHIHAi] output ready for double difference maps.</p>

<h3><a name="general_hlout"></a>HLOUT</h3>

<p>Causes output of Hendrickson-Lattman coefficients.<br />
Default labels HLA HLB HLC HLD</p>

<h3><a name="general_print"></a>PRINT [STATS] [AVF] [AVE] .... [NOSTATS] [MON &lt;nmon&gt;]
[COR]</h3>

<p>The subsidiary keywords control the type of output. Default is to output
statistics for the final cycle only. Refinement statistics only include 
reflections used for a REFINEMENT pass
for that derivative. The final statistics will include information from all reflections.
If you are only doing phasing, for instance after changing hand, no statistics are output. 
</p>

<p>Possible keywords are:</p>

<dl>
<dt><a name="general_print_stats"></a>STATS</dt>

<dd>statistical output and xloggraphs for last refinement cycle and final phasing cycle.</dd>

<dt><a name="general_print_nostats"></a>NOSTATS</dt>

<dd>no statistics output.</dd>

<dt><a name="general_print_mon"></a>MON &lt;nmon&gt;</dt>

<dd>Set this if you want to monitor every &lt;nmon&gt;-th reflection.
The default is every 10-th reflection.</dd>

<dt><a name="general_print_cor"></a>COR</dt>

<dd>Output correlation matrix (default: do not)</dd>
</dl>

<p>Keywords to control type of statistical analysis.</p>

<pre>
     The " OLD WEIGHT ( W1)" is defined as:
     W1 = (Phase Prob of all phases) /(SIG(Fph)**2 + VCALC + IsoError**2(resn) )
 where VCALC = SIGFP**2 *((FPSQ + FPA * FHA + FPB * FHB) / (FP * FPH))**2
     FPA = FP * COS(PhiX)   FHA = FH * COS(PhiH)
     FPB = FP * SIN(PhiX)   FHB = FH * SIN(PhiH)

     The " NEW WEIGHT ( W2)" is defined as:
     W1 = Phase Prob /(SIG(Fph)**2 + SIG(Fp)**2)

</pre>
<dl>
<dt><a name="general_print_avf"></a>AVF</dt>

<dd>gives unweighted Average FP FPH FH</dd>

<dt><a name="general_print_ave"></a>AVE</dt>

<dd>gives unweighted Average Lack_of_closure terms.</dd>

<dt><a name="general_print_rmsf"></a>RMSF</dt>

<dd>gives unweighted rms FP FPH FH</dd>

<dt><a name="general_print_rmse"></a>RMSE</dt>

<dd>gives unweighted rms Lack_of_closure terms.</dd>

<dt><a name="general_print_w1ave"></a>W1AVE</dt>

<dd>gives weighted Average FP FPH FH summed over the phase circle</dd>

<dt><a name="general_print_w2ave"></a>W2AVE</dt>

<dd>gives weighted Average Lack_of_closures summed over the phase circle</dd>

<dt><a name="general_print_w1rmse"></a>W1RMSE</dt>

<dd>gives weighted rms FP FPH FH summed over the phase circle</dd>

<dt><a name="general_print_w2rmse"></a>W2RMSE</dt>

<dd>gives weighted rms Lack_of_closures summed over the phase circle</dd>
</dl>

<p>There is some debate over which type of statistic is the most useful.
EJD uses AVE and AVF. It is important to use only ONE option, otherwise
you are swamped with information, and to stick to that option. To assess
whether new sites are contributing EJD looks for a reduction in the Cullis
R-factors as new sites are added. See <a href="#notes_on_usage">NOTES ON USAGE</a> for hints on using
this information.</p>


<h3><a name="general_resolution"></a>RESOLUTION [ &lt;rmin&gt; ] &lt;rmax&gt;</h3>

<p>Overall resolution range for all refinement and phasing in Angstroms
(or as 4sin(theta)**2/lambda**2 limits iff both are &lt;1.0). If only one
limit is given, it is the upper limit; otherwise the limits can be in either
order. The default is to use the resolution from the MTZ file. Data for
derivatives can each be limited by a further <a href="#derivative_resolution">RESOLUTION</a> keyword after the
<a href="#derivative_deriv">DERIVATIVE</a> definitions.</p>

<h3><a name="general_scale"></a>SCALE SIGFP &lt;scale&gt;</h3>

<p>Specifies the scale factor by which to multiply SIGFP. The default is
&lt;scale&gt;=1.</p>

<h3><a name="general_threshold"></a>THRESHOLD &lt;thr&gt; &lt;acl&gt;</h3>

<p>These parameters allow you to modify large shifts in any parameter.
If any parameter_shift exceeds &lt;thr&gt;*SD_parameter_shift then the
shift is dampened by &lt;acl&gt;. The default is &lt;ac1&gt;=1, &lt;thr&gt;
not set.</p>

<h3><a name="general_title"></a>TITLE &lt;title&gt;</h3>

<p>The specified title is written to the HKLOUT file. The default is the
title from the MTZ file.</p>

<h3><a name="general_script"></a>SCRIPT</h3>

<p>This will produce a unix script. One can then run
MLPHARE again but with the refined heavy atom parameters in the <a href="#derivative_atom">ATOM</a>, <a href="#derivative_isoerror">ISOERROR</a>
and <a href="#derivative_anoerror">ANOERROR</a> cards. The other input cards will be the same as in the original
script. However, the <a href="#derivative_atref">ATREF</a> cards will allow refinement of all parameters
in every cycle. The output script file is assigned to NEWPARM.</p>

<h3><a name="general_coords"></a>COORDS</h3>

<p>This will cause the program to output the refined coordinates of the heavy
atom sites into the external file with logical name XYZOUT, in a pseudo-PDB
format suitable for input into a viewing program <em>e.g.</em> RASMOL.</p>

<p>The file contains CRYST1 and SCALE cards, and the following data for each
site appears on an ATOM record (from left-to-right):</p>
<table border="0">
<tr>
  <th align="left">Position in pseudo-PDB file</th>
  <th align="left">Quantity</th>
</tr>
<tr>
  <td>7-12 (Atom serial number)</td>
  <td>Position of the site in the list</td>
</tr>
<tr>
  <td valign="top">13-14 (Chemical symbol)</td>
  <td>Chemical symbol of heavy atom (supplied on <a href="#derivative_atom">ATOM</a> keyword)</td>
</tr>
<tr>
  <td>23-26 (residue number)</td>
  <td>Derivative number</td>
</tr>
<tr>
  <td>31-54 (angstrom orthogonal coordinates)</td>
  <td>Refined X,Y,Z orthogonal coordinates of the site</td>
</tr>
<tr>
  <td>55-60 (occupancy)</td>
  <td>Refined occupancy of the site</td>
</tr>
<tr>
  <td>61-66 (iso b-factor)</td>
  <td>Refined isotropic B-factor</td>
</tr>
</table>

<h4>Data Harvesting keywords</h4>

<p>Provided a Project Name and a Dataset Name are specified (either explicitly
or from the MTZ file) and provided the <a href="#general_noharvest">NOHARVEST</a>
keyword is not given, the program will automatically produce a data harvesting
file. This file will be written to</p>

<p><tt>$HARVESTHOME</tt>/<tt>DepositFiles</tt>/<i>&lt;projectname&gt;</i>/
<i>&lt;datasetname&gt;.mlphare</i></p>

<p>The environment variable <tt>$HARVESTHOME</tt> defaults to the user's
home directory, but could be changed, for example, to a group project
directory. When running the program through the CCP4 interface, the $HARVESTHOME variable defaults to the 'PROJECT' directory.</p>

<h3><a name="general_pname">PNAME</a>&lt;project_name&gt;</h3>

<p>Project Name. In most cases, this will be inherited from the MTZ file.</p>

<h3><a name="general_dname">DNAME</a>&lt;dataset_name&gt;</h3>

<p>Dataset Name. In most cases, this will be inherited from the MTZ file.</p>

<h3><a name="general_private">PRIVATE</a></h3>

<p>Set the directory permissions to '700', <em>i.e.</em> read/write/execute for
the user only (default '755').</p>

<h3><a name="general_usecwd">USECWD</a></h3>

<p>Write the deposit file to the current directory, rather than a
subdirectory of $HARVESTHOME. This can
be used to send deposit files from speculative runs to the local directory
rather than the official project directory, or can be used 
when the program is being run on a machine without access to the directory
<tt>$HARVESTHOME</tt>.</p>

<h3><a name="general_rsize">RSIZE</a>&lt;row_length&gt;</h3>

<p>Maximum width of a row in the deposit file (default 80).
&lt;row_length&gt; should be between 80 and 132 characters.</p>

<h3><a name="general_noharvest">NOHARVEST</a></h3>

<p>Do not write out a deposit file; default is to do so provided Project
and Dataset names are available.</p>

<h3>Set 2: derivative keywords</h3>

<b>Next cards are repeated once for each derivative</b>

<h3><a name="derivative_deriv"></a>DERIV &lt;title&gt;</h3>

<p>&lt;title&gt; is used to flag the output. Be informative! (Compulsory
for each derivative assigned on the LABIN line.)</p>

<h3><a name="derivative_dcycle"></a>DCYCLE [PHASE] i1 i2 [REFCYCLE] j1 j2 [KBOVERALL]
k1 k2</h3>

<p>Subsidiary keywords PHASE, REFCYCLE, KBOVERALL control the use of this
derivative. Default is NOT to use the derivative for PHASE, REFC and KBOV.</p>

<pre>  <a name="derivative_dcycle_phase"></a>PHASE [ALL] or i1 i2 ... 
  <a name="derivative_dcycle_refcycle"></a>REFCYCLE [ALL] or j1 j2 ... 
  <a name="derivative_dcycle_kboverall"></a>KBOVERALL [ALL] or k1 k2 ...  
</pre>

<p>Then the derivative is used for:<br />
phasing on cycles i1 i2 ... refining on cycles j1 j2 ...<br />
The overall scale and B are refined on cycles k1 k2 ...<br />
(The word ALL means act on all cycles...)</p>

<h3><a name="derivative_exclude"></a>EXCLUDE [SIGFPH &lt;siglim&gt;] [DISO &lt;isolim&gt;]
[DANO &lt;anolim1 anolim2&gt;]</h3>

<dl>
<dt><a name="derivative_exclude_sigfph"></a>SIGFPHi &lt;siglim&gt;</dt>

<dd>Reflections are excluded if FPHi &lt; siglim*SIGFPHi. Default is &lt;siglim&gt;=0.</dd>

<dt><a name="derivative_exclude_diso"></a>DISO &lt;isolim&gt;</dt>

<dd>Reflections are excluded if abs(FPHi-FP) &gt; &lt;isolim&gt;. The
default is &lt;isolim&gt; unset and unused.</dd>

<dt><a name="derivative_exclude_dano"></a>DANO &lt;anolim1&gt; [ &lt;anolim2&gt; ]</dt>

<dd>Reflections are excluded if abs(FPHi(+) -FPHi(-)) &gt; &lt;anolim1&gt;.
The default is unset. Reflections can also be excluded if abs(FPHi(+) -FPHi(-))
&lt; &lt;anolim2&gt;. EJD feels it is very unwise to use this.</dd>
</dl>

<h3><a name="derivative_scale_fph"></a>SCALE FPHi &lt;scale&gt; &lt;b&gt;</h3>

<p>(i=1,2...) followed by &lt;scale&gt; and &lt;b&gt; to apply to FPHi
and SIGFPHi as exp(-&lt;b&gt;*ss)/&lt;scale&gt;. The defaults are &lt;scale&gt;=1,
&lt;b&gt;=0 which should be sufficient if the data has been through <a href="fhscal.html">FHSCAL</a>
or <a href="scaleit.html">SCALEIT</a>.<br />
&lt;scale&gt; and &lt;b&gt; may subsequently be refined by the program,
see <a href="#derivative_dcycle">DCYCLE</a> keyword.</p>

<h3><a name="derivative_scale_sigfph"></a>SCALE SIGFPHi &lt;scale2&gt;</h3>

<p>&lt;scale2&gt; is used to further scale up SIGFPHi. Final SIGFPHi =
&lt;scale2&gt;*exp(-&lt;b&gt;*ss)/&lt;scale&gt;<br />
The default is &lt;scale2&gt;=1.</p>

<h3><a name="derivative_resolution"></a>RESOLUTION [ &lt;rmin&gt; ] &lt;rmax&gt;</h3>

<p>Specify resolution limits to use for this derivative (as <a href="#general_resolution">above</a> for the
overall resolution).</p>

<h3><a name="derivative_resolution_ano"></a>RESOLUTION ANO &lt;rmin&gt; &lt;rmax&gt;</h3>

<p>Resolution range for use of anomalous data for this derivative (defaults
to limits for isomorphous data).</p>

<h3><a name="derivative_isoerror"></a>ISOERROR &lt;ierr1&gt; &lt;ierr2&gt; ... &lt;ierr8&gt;</h3>

<p>Eight numbers giving the estimated isomorphous lack of closure error
as a function of resolution. For initial refinements do not give these,
and allow the program to evaluate them. If running a final phasing pass,
take the values output at the end of the refinement cycle.</p>

<h3><a name="derivative_anoerror"></a>ANOERROR &lt;aerr1&gt; &lt;aerr2&gt; ... &lt;aerr8&gt;</h3>

<p>Eight numbers giving the estimated anomalous lack of closure error as
a function of resolution. For initial refinements allow the program to
evaluate these. For a final phasing pass, take the values output at the
end of a refinement cycle.</p>

<h3><a name="derivative_atom"></a>ATOM &lt;ID&gt; &lt;Xfrac&gt; &lt;Yfrac&gt; &lt;Zfrac&gt;
&lt;occ&gt; [&lt;aocc&gt;] BFAC &lt;b1&gt; [&lt;b2&gt; &lt;b3&gt; &lt;b4&gt;
&lt;b5&gt; &lt;b6&gt;]</h3>

<p>One for each site (at least one site must be given for each derivative).</p>

<dl>
<dt><a name="derivative_atom_id"></a>&lt;ID&gt;</dt>

<dd>Atom identifier which must match a form factor given in the file assigned
to ATOMSF (default $CLIBD/atomsf.lib). The standard form factors are given
for the CuKa wavelength, so the values of f' and f'' may not be appropriate
for other wavelengths. You will need to interpret your occupancies intelligently:
<! --  Following from Laurence Pearl: -- >the refinement of the real and
anomalous occupancies models f' and f'' perfectly well, and can be used
to phase and refine with heavy atom data collected at multiple wavelengths.
Selecting &lt;ID&gt; = Ano sets f' and f'' equal to 1 so that everything
is included in the real and anomalous occupancies.
In fact using MLPHARE for multiple wavelength data has generally been found
to be better, and easier than the geometric phasing method proposed by
Karle and Hendrickson.</dd>

<dt><a name="derivative_atom_frac"></a>&lt;Xfrac&gt; &lt;Yfrac&gt; &lt;Zfrac&gt;</dt>

<dd>atomic coordinates given as fractions of unit cell.</dd>

<dt><a name="derivative_atom_occ"></a>&lt;occ&gt;</dt>

<dd>atom occupancy. Remember this will probably be on an arbitrary scale.
At this stage you are unlikely to have amplitudes on the absolute scale.</dd>

<dt><a name="derivative_atom_aocc"></a>&lt;aocc&gt;</dt>

<dd>anomalous occupancy. Remember this will probably be on an arbitrary
scale too. See <a href="#notes_on_usage">NOTES ON USAGE</a> for interpretation of sign.</dd>

<dt><a name="derivative_atom_bfac"></a>&lt;b1&gt; [&lt;b2&gt; &lt;b3&gt; &lt;b4&gt;
&lt;b5&gt; &lt;b6&gt;]</dt>

<dd>If only &lt;b1&gt; is set, &lt;b1&gt; is the isotropic temperature
factor If &lt;b1&gt; &lt;b2&gt; &lt;b3&gt; &lt;b4&gt; &lt;b5&gt; &lt;b6&gt;
are set, they define the anisotropic &lt;b&gt; factor. The temperature
factor is defined as:<br />
exp(-(h*h*&lt;b1&gt; + h*k*&lt;b2&gt; + h*l*&lt;b3&gt; + k*k*&lt;b4&gt;
+ k*l*&lt;b5&gt; + l*l*&lt;b6&gt;))<br />
For a rough approximation to give an anisotropic B factor take &lt;b1&gt;
= &lt;b4&gt; = &lt;b6&gt; = &lt;b&gt;, &lt;b2&gt; = &lt;b3&gt; = &lt;b5&gt;
= 0.</dd>
</dl>

<p>The isotropic B factor is approximated by 1/3(&lt;b1&gt;+&lt;b4&gt;+&lt;b6&gt;).</p>

<p>Following Willis and Pryor conventions, I think</p>

<pre>           b1 = k*beta11, b4 = k*beta22, b6=k*beta33
           b2 = k*beta12, b3 = k*beta31, b5=k*beta23
where their temperature factor is expressed as:

 exp(-0.25(  h**2 * (a*)**2 * beta11 + k**2 * (b*)**2 * beta22
           + l**2 * (c*)**2 * beta33  + 2*k*l*(b*)*(c*)*beta23  
           + 2*l*h*(c*)*(a*) *beta31 + 2*h*k*(a*)*(b*) *beta12))
</pre>

<p>This means the Uij terms of an anisotropic temperature factor is equal
to betai */(8*pi**2).</p>

<h3><a name="derivative_atref"></a>ATREF [ [X | AX] [ALL | &lt;k1&gt; &lt;k2&gt;...] ]
[Y | AY ... Z | AZ ...] [OCC [ALL | &lt;i1&gt; &lt;i2&gt;... ]]
[AOCC [ALL | &lt;j1&gt; &lt;j2&gt; ...]]
[ [B | AB] [ALL | &lt;l1&gt; &lt;l2&gt;...] ]</h3>

<p>The keywords X or AX, Y or AY, Z or AZ, OCC, AOCC, B or AB flag which parameter
should be refined. X Y Z mean refine coordinate to fit the isomorphous
differences. AX AY AZ mean refine coordinates to fit the anomalous differences
(only one of X or AX can be used). Similarly for B and AB. The keyword ALL 
means refine parameter on all cycles. Numbers &lt;i1&gt; &lt;i2&gt; etc. mean 
refine parameters on the numbered cycles only.</p>

<h3><a name="derivative_wave"></a>WAVE &lt;wavelength&gt; [FPR &lt;f'&gt;] [FDP &lt;f"&gt;]</h3>

<p>The keyword <b>WAVE</b> specifies the wavelength for this derivative.
It allows the user to alter the default values of f' and f&quot; for the heavy atom. Specify the
f' (<b>FPR</b>) and f" (<b>FDP</b>) at  this wavelength.</p>
<pre>
Example:

  WAVE  0.9000  FPR -1.622  FDP 3.285
  WAVE  0.9795  FPR -8.198  FDP 2.058
  WAVE  0.9809  FPR -6.203  FDP 3.663
</pre>

<h3><a name="general_end"></a>END</h3>

<p>Each DERIVATIVE set finishes with another DERIV card or END.</p>

<h2><a name="files"></a>INPUT AND OUTPUT FILES</h2>

<p>The input files are:</p>

<ol type="a">
<li>The control data file</li>
<li>The input reflection data file in standard MTZ format.</li>
</ol>

<p>The output files are:</p>

<ol type="a">
<li>A log file which contains a complete description of the calculation
plus some extremely useful XLOGGRAPH tables (see <a href="xloggraph.html">xloggraph documentation</a>
for instructions on how to display these). The final lines are in the format
for updating the control data file; containing refined heavy atom scale
factors, calculated lack of closure errors and parameters. You can edit
these back into the next control data file or set the <a href="#general_script">SCRIPT</a> keyword. Take
care to reset the <a href="#derivative_atref">ATREF</a> flags to do what you want to do.</li>

<li>A reflection data file which will copy some or all of the input reflection
data file with the following additional columns:

<blockquote><dl>
<dt>PHIB</dt>
<dd>Phase</dd>
<dt>FOM</dt>
<dd>Figure of merit</dd>
<dt>[HLA,HLB,HLC,HLD]</dt>
<dd>Hendrickson-Lattman coefficients if required</dd>
<dt>[FHi PHIHi [ FHAi PHIHAi ] ]</dt>
<dd>Two or four items per derivative if FHOUT requested.</dd>
</dl></blockquote>
</li>

<li>A script/COM file which can run mlphare again but contains the refined
heavy atoms parameters mentioned in a).</li>
</ol>

<h2><a name="notes_on_usage"></a>NOTES ON USAGE - Eleanor Dodson</h2>

<p>Definitions of abbreviations:</p>

<dl>
<dt>MIR</dt>

<dd>Multiple Isomorphous Replacement - generating protein phases from
the observed differences between FP and several FPHi, and the FHi vectors
calculated from the various sets of heavy atom positions.</dd>

<dt>MIRAS</dt>

<dd>Multiple Isomorphous Replacement - generating protein phases from
the observed differences between FP and the FPHi(+) and FPHi(-) + FHi</dd>

<dt>SIR</dt>

<dd>Single Isomorphous Replacement - generating protein phases from the
observed differences between FP and one FPH + FHi</dd>

<dt>SIRAS</dt>

<dd>Single Isomorphous Replacement - generating protein phases from the
observed differences between FP and one FPH(+) and FPH(-) and FHi</dd>

<dt>MAD</dt>

<dd>Multi-wavelength Dispersion - generating protein phases from the observed
differences between several sets of FPH(+) and FPH(-) measured at different
wavelengths where the f' and f of the heavy atom scatterer are different,
and the FH vectors calculated from these heavy atom positions.</dd>
</dl>

<p>See the <a href="#examples">EXAMPLES</a> for detailed comments on heavy atom analysis.</p>

<p>This program refines heavy atoms without significant bias, and estimates
figure of merits realistically. THIS MEANS THAT THE OUTPUT WILL PERFORM
MUCH BETTER AFTER SOLVENT FLATTENING OR DENSITY MODIFICATION THAN BEFORE.
Mlphare is NOT usually used to generate the phases for the map to be interpreted
- it is giving you an INITIAL STARTING point for '<tt>dm</tt>' or some other phase
improvement procedure. Thus the reliability of the Figure of Merits is
the most important information it gives.</p>

<p><a name="ejd_choose_data"></a>It is sensible to refine heavy atoms occupancies first against the centric
data, if you have some. This gives very similar answers to 3D data in a
fraction of the time. It is possible to phase on some derivatives and refine
others. In my experience this gives answers very close to the default procedure
of including all parameters for both phasing and refinement.</p>

<p><a name="ejd_exclude_data"></a>It is sensible to exclude any suspect data from the heavy atom refinement.
Using a sigma cutoff and values for DISO and DANO chosen using <a href="scaleit.html">SCALEIT</a>
output reduced the standard deviation of parameters. Phases are calculated
for all reflections to the outer resolution limit on the final cycle. The
option to input external phases seems to work. But I am not sure of the
theoretical correctness of this. There can't be much maximum likelihood
going on. See <a href="#notes_on_phic">NOTES ON PHIC</a> - I think the relative weighting of the PHIC
contribution is probably not very sensible. But it is really not necessary
- there is so little evidence of bias in standard calculations I would
never recommend using it here. (Of course externally obtained phases can
be very helpful in doing difference Fourier to help you find the sites
in the first place...)</p>

<p><a name="ejd_ghosting"></a>For the best phasing you need to find all the significant sites in a
derivative. After you have found and refined the first set of sites you
can use a difference Fourier with these SIR phases to find other sites.
However these maps will usually show confusing ghosting in the vicinity
of the existing sites. <a name="ejd_crossdiff_fourier"></a>Alternatively, you can use the procedure below which
uses cross difference Fouriers to find sites in other derivatives. If
you have several independent derivatives, one good procedure is to refine
the heavy atom sites of the first, use the SIR phases from this one to
do difference Fouriers for the second; check that sites found in the second
derivative difference maps correspond to Patterson peaks. Repeat the procedure
with the SIR phases from the second derivative and confirm these maps show
the sites in the first derivative, and so on. HOWEVER many things can go
wrong! The most troublesome is trying to decide whether the derivatives
have common sites. The SIR phases usually generate ghost peaks and holes
in the neighbourhood of the first site, which can be very confusing. And
very often heavy atom sites sit on symmetry points, so the SIR phases are
essentially centric, and maps phased with them contain peaks at both xyz
AND -x,-y,-z...</p>

<p><a name="ejd_origin_convention"></a>The advantage of this cross difference Fourier approach is that your
sites for a second derivative will be determined relative to the same origin
as the first. Pattersons alone in P212121 can give solutions of either
(x,y,z) + (n1/2,n2/2,n3/2) or (-x,-y,-z) + (n1/2,n2/2,n3/2) where n1,n2,n3
can be either 0, or 1; <em>i.e.</em> there are 16 possibilities to consider. It
doesn't matter for the first site you choose but all others within that
derivative and all others must follow the same convention.</p>

<p><a name="ejd_determine_hand"></a>Assuming you now have two derivatives consistent with each other, you
can refine the anomalous occupancies of both beginning with AOCC = 0.00
and they should all become either positive, in which case you have chosen
the right hand, or negative, so you need to use the enantiomorph if you
wish to see right handed alpha helices. Note that FOM will not be able
to distinguish between the enantiomorphs. You can visualise this by appreciating
that changing hand generates phase circles which are mirrored through the
line PHI=0 and therefore have the same quality crossings. One hand gives
phases PHIB and the other phases -PHIB.</p>

<p>Another approach which is worth following in cases where you have anomalous
data (and there should not be any where you don't..) is the following:<br />
Refine the single derivative heavy atom real occupancies (using centric
data if you have enough) then start refining the anomalous occupancies
(using all the data). You will need to start them all at some positive
value; otherwise they will stick at 0.0000. If the derivative and data
are OK all occupancies should stay with the same sign. You then need to
recalculate the phases with the other enantiomorph; here the FOM will be
the same, but the phases will not be just the mirror image of the first
set. Don't forget: Changing the enantiomorph requires changing the space-group
as well for some space-groups, <em>e.g.</em> P41/P43; P31/P32, P61/P65 P62/P64 and
variants. There is even an awful cubic one where you have to move the origin.
This requires you run mtzutils or cad to produce a new mtz file with a
different spacegroup defined in the header. Now you have two sets of SIRAS
phases, you choose between them by looking at maps. Difference Fouriers
for one enantiomorph SHOULD give clearer peaks than for the other. '<tt>dm</tt>' output
for one set of phases should give better statistics than for the other.
BUT this distinction can be very marginal; if your anomalous occupancies
refine away towards 0.0 there will be no distinction of course.</p>

<p><a name="ejd_mad"></a>Here are some specific notes on using mlphare to refine and phase from
MAD data. This is simply a special case of MIR phasing, where now the real
occupancies will be proportional to the f'(j) -f'(P), and the anomalous
occupancies are proportional to f(j) . The FP assignment must be the same
as one of the FPHi and that DERIVATIVE will have all real occupancies ==
0.0 and these cannot be refined. The enantiomorph problem is now particularly
serious; since all the FH vectors are parallel to each other, it is possible
to reflect the phase circle diagram both about AlphaH ( equivalent to changing
coordinates to the other hand) AND about the direction AlphaH +90 ( equivalent
to getting the sign of the f'(j) -f'(P) reversed.) and in each case to
get exactly the same Figures of Merit. Since the wavelength for each data
set is known it is possible to get the signs of the real occupancies correct.
Be careful!! It may be best to have as the 'native', the data set collected
at the lowest f' wavelength so that all real occupancies should be positive,
but if this data set is incomplete there may be a good reason to choose
another.</p>

<p><a name="ejd_procedure_summary"></a>Our procedure is summarised here:</p>

<pre>
  Find anomalous scatterer sites
  ( Patterson? Shelx90?? However..)

  Refine real occupancies and XYZ using CENTRIC option for
  MLPHARE doing each pair of wave lengths independently.
  This is very quick - seems more accurate than using all
  data, and gives independent estimates of how good your f'
  estimates are.

  ( the ratios of f'(j)-f'(P) should be constant for all
  sites - they will NOT be on the absolute scale though..)

  Then we take those real occupancies and ISOE tables and
  hold them fixed while refining the anom occupancies ( you
  must remember to use ATREF AX ALL AY ALL AZ ALL etc  if you
  want to refine any other parameter to make sure the
  anomalous differences are used)

  As I said push the occupancies towards the positive sign
  by a bit. Obviously it is bad if you get some positive and
  some negative, and again the ratio of the different
  occupancies should reflect the expected f'' values ( I am
  afraid they are never spot on for us - we can't be so good
  at staying on the inflection point..)

  This refinement with all the data will give sites and
  ANOEs, and these can be cut and pasted into a test where
  the x y z sign is reversed.

  THEN we do two things: <b>look at maps</b> - one map should have
  a clearer solvent boundary than the other, and <b>run DM</b> -
  and one hand should give marginally better statistics than
  the other.

  It works - providing the data is good enough, the anomalous
  scatterer is correctly positioned, and none of the other
  disasters which can occur have occurred!
</pre>

<p>A common one is: Starting X Y Z refinement with ALL occupancies zero.
This means there are no sensible gradients for x y z and they can slide
about.</p>

<h2><a name="notes_on_phic"></a>NOTES ON PHIC</h2>

<p>In order to merge information about external phases with MIR phase information,
an extra calculated phase probability contribution is calculated.</p>

<pre>
 PROB(PHASEi)= PROB(PHASEi) + exp(-((FPAi-WC*FCA)**2
                            + (FPBi-WC*FCB)**2))/
                    ((FC*(1-WC))**2 + sigma(fnat)**2)
     FPAi = FP*cos(PHASEi)
     FPBi = FP*sin(PHASEi)
     FCA  = FC*cos(PHIC)
     FCB  = FC*sin(PHIC)
  if FC is not input, then FC equals FP
  if WC is not input WC = 1.

</pre>

<p>See <a href="#examples">examples</a>.</p>

<h2><a name="notes_on_occupancies"></a>NOTES ON OCCUPANCIES</h2>

<p>The occupancies used by heavy atom refinement programs are on the same
scale as FP, so if you haven't put your data on an absolute scale (and
you can't without using high resolution data) the occupancies will not
be absolute. <em>E.g.</em>, if your FPs are 10 times absolute, your occupancies
should be in the range 0 to 10. Because all your derivatives have to be
on the same scale as FP, using relative occupancies will not affect the
results in any way (except of course for the apparent non-physical meaning
of occupancies &gt;1!).</p>

<h2><a name="output"></a>PRINTER OUTPUT</h2>

<p>The printer output starts with details from the control data file followed
by details of the input reflection data file and the header information
written to the output reflection data file.</p>

<p>After each cycle the current error estimates and figure of merit are
tabulated over the resolution range. The new parameters and their standard
deviations are listed. <em>N.B.</em>: If an occupancy becomes near to 0.0 the coordinate
shifts will possibly be meaningless.</p>

<p>Then for the last cycle of the refinement the following sections are
output giving an extensive statistical analysis of the results of the refinement.
This is repeated for the final phasing cycle, which may well involve more
reflections.</p>

<p>For each compound the following sections are output:</p>

<ol type="i">

<li>Details of the parameters for each heavy atom site of the compound,
details of the correlation matrix if requested. The determinant of the
normal matrix.</li>

<li>The refinement parameter for isomorphous and anomalous differences.
At convergence these should be ~1.0</li>

<li>Analysis of Differences between Heavy Atom and Protein Phases:
<ol type="a">
<li>as a Function of Figure of merit</li>
<li>as a Function of Resolution</li>
</ol>
</li>
</ol>

<p>Note:</p>

<ol type="i">
<li>The mean difference should be ~90. If it is not, the scale between
FP and FPH is probably wrong.</li>

<li>The standard deviation of the distribution should be 51.96 for acentric
reflections, and 90 for centric reflections if the protein phases are based
on several independent derivatives. The table gives:
<pre>          &lt;FOM&gt; range
     or [ &lt;4SSQ/LL&gt;  range
          Resolution (Angstroms) ]
          Number of reflections                  (acentrics)
          Average Phase difference               (acentrics)
          Standard deviation of phase difference (acentrics) 

          Number of reflections                  (centrics)
          Average Phase difference               (centrics)
          Standard deviation of phase difference (centrics)</pre>

<li>Analysis of average or rms FP FPH and FH as a Function of Resolution.
For acentric reflections the FH components derived from the fh-fh' and
from the fh'' are listed separately. The values can be weighted - see keyword
PRINT for details.<br />
The table gives:
<pre>          &lt;4SSQ/LL&gt;  range
          Resolution (Angstroms)
          Number of reflections                  (acentrics)
          Mean or rms FP                         (acentrics)
          Mean or rms FPH                        (acentrics)
          Mean or rms calculated FH_real         (acentrics)
          Mean or rms calculated FH_imag         (acentrics)

          Number of reflections                  (centrics)
          Mean or rms FP                         (centrics)
          Mean or rms FPH                        (centrics)
          Mean or rms calculated FH_real         (centrics)</pre>
</li>

<li>Analysis of average or rms isomorphous lack of closure as a function
of resolution. The values can be weighted - see keyword <a href="#general_print">PRINT</a> for details.<br />
Isomorphous difference is |FPHi -FP|.<br />
Lack of closure is |FPHi - |FP+FH|| where |FP+FH| is a vector sum of the
calculated FH, phase PHIH and FP with the protein phase. For the unweighted
averages or rms entries the protein phase is that obtained by MLPHARE.<br />
For the weighted tables every value of PHIx around the phase circle is
included with the appropriate weight. Since the weights for most values
of PHIx are ~0.0 these tables should give similar results to the unweighted
ones.<br />
Phasing power is &lt;FH/ Lack_of_closure&gt;.<br />
Cullis R factor is &lt;Lack_of_closure&gt;/&lt;Isomorphous difference&gt;.
<em>N.B.</em>: This is tabulated for acentric and centric terms, extending the former
definition.<br />
It is the most useful signal for a usable derivative. Values &lt; 0.6 for
centric data are excellent; values &lt; 0.9 are usable. If a new site does
not reduce the Cullis R factor it is probably not correct.<br />
The table gives:
<pre>          &lt;4SSQ/LL&gt;  range
          Resolution (Angstroms)
          Number of reflections                  (acentrics)
          Mean or rms isomorphous difference     (acentrics)
          Mean or rms lack of closure            (acentrics)
          Phasing power                          (acentrics)
          Cullis R factor                        (acentrics)

          Number of reflections                  (centrics)
          Mean or rms isomorphous difference     (centrics)
          Mean or rms lack of closure            (centrics)
          Phasing power                          (centrics)
          Cullis R factor                        (centrics)</pre>
</li>

<li>Analysis of average or rms anomalous lack of closure as a function
of resolution. The values can be weighted - see keyword <a href="#general_print">PRINT</a> for details.<br />
Anomalous difference is |FPHi(+) -FPHi(-)|.<br /> Calculated anomalous difference
is 2 * FHi * sin(PHIx) where PHIx is the protein phase.<br /> Lack of closure
is | Anom.Diff - Calc.Anom.Diff|.<br /> Cullis R factor is &lt;Lack_of_closure&gt;/
&lt;Anomalous difference&gt;. This is tabulated for acentric terms. Any
value &lt;1.0 means there is some contribution to the phasing from the
anomalous data.<br />
The table gives:
<pre>          &lt;4SSQ/LL&gt;  range
          Resolution (Angstroms)
          Number of reflections                  (acentrics)
          Mean or rms anomalous difference       (acentrics)
          Mean or rms calculated anomalous difference     (acentrics)
          Mean or rms lack of closure            (acentrics)
          Cullis R factor                        (acentrics)</pre>
</li>

<li>Table of estimated error in the isomorphous and anomalous differences.
These are the values to enter with keywords <a href="#derivative_isoerror">ISOERROR</a> and
<a href="#derivative_anoerror">ANOERROR</a>.</li>

<li>Table of figure of merit as a function of resolution. The table gives:
<pre>          &lt;4SSQ/LL&gt;  range
          Resolution (Angstroms)
          Number of reflections                  (acentrics)
          Mean figure of merit                   (acentrics)

          Number of reflections                  (centrics)
          Mean figure of merit                   (centrics)</pre>
</li>

<li>The refinement parameter</li>

<li>If anomalous data are being used for the compound then the anomalous
refinement parameter is given.</li>
</ol>

<h2><a name="possible_errors"></a>ERRORS DURING PHASE CALCULATION</h2>

<p>If the lack of closure is very bad and the phase is virtually undetermined,
the following error message is output, and the program continues.</p>

<blockquote>Reflection HKL: 0 4 1 has inconsistent phase likelihood, log Pmax=
0.13E+05</blockquote>

<h2>ERRORS DURING MATRIX SOLUTION</h2>

<p>If there are problems in solving the matrix for the refinement of the
heavy atom parameters then the following message may be printed and the
program will stop. This often means occupancies have become 0.00. Trying
to refine coordinates for a site at a special position can also give this
error.</p>

<blockquote>**** IN SUBROUTINE MATSOL DET IS LESS THAN 10E-30 ****</blockquote>

<h2><a name="caveat"></a>CAVEAT</h2>

<p>Note the comment above about errors during matrix solution when trying
to refine coordinates for a site at a special position. In certain cases,
this might not cause an error per se, but simply yield less-than-perfect
occupancies etc. Check that the fixed parameters for the special position
are NOT refined!</p>

<h2>SEE ALSO</h2>

<p><a href="vecref.html">VECREF</a> - vector-space refinement of heavy atom sites</p>

<h2><a name="examples"></a>EXAMPLES</h2>

<h3>Example 1</h3>

<h3>Simple unix example script found in $CEXAM/unix/runnable/</h3>

<li><a href="../examples/unix/runnable/mlphare.exam">mlphare.exam</a> (heavy
atom refinement and phasing).</li>

<h3>Also found combined with other programs in the example scripts ($CEXAM/unix/runnable/)</h3>

<li><a href="../examples/unix/runnable/phistats.exam">phistats.exam</a>
(phase analysis)</li>

<li><a href="../examples/unix/runnable/mir_steps">mir_steps</a> (heavy
atom refinement and phasing)</li>

</ul>

</body>
</html>
